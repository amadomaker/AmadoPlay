<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Jogo Conexo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700;800&display=swap" rel="stylesheet">
    <!-- Lottie: usar jsDelivr confi√°vel -->
    <script src="https://cdn.jsdelivr.net/npm/lottie-web@5.12.2/build/player/lottie.min.js" defer></script>
    <script src="../src/data/conexo-puzzles.js" defer></script>
    <style>
        body {
            font-family: 'Montserrat', sans-serif;
            background: linear-gradient(135deg, #6c63ff 0%, #7c4dff 35%, #9c27b0 70%, #673ab7 100%);
            color: white;
            touch-action: manipulation; /* Melhora a resposta ao toque em dispositivos m√≥veis */
            -webkit-text-size-adjust: 100%; /* Previne o zoom autom√°tico de fontes no iOS */
        }
        .game-wrapper {
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            border-radius: 20px;
            padding: 1.5rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }
        .card {
            transition: transform 0.1s ease-in-out, background-color 0.2s ease-in-out, color 0.2s ease-in-out;
            -webkit-tap-highlight-color: transparent; /* Remove o destaque azul ao tocar em links no iOS */
            word-break: break-word;
            height: 80px; /* Altura fixa para controlar o layout vertical */
            font-size: clamp(0.8rem, 2.5vw, 1.1rem); /* Fonte responsiva e segura */
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
        }
        .card.selected {
            transform: scale(0.95);
            background-color: #6d28d9; /* violet-700 */
            color: white;
        }
        .solved-card {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
            color: black;
            font-weight: 500;
        }
        .solved-card-words {
            font-weight: 700;
            text-transform: uppercase;
        }
        .shake {
            animation: shake 0.5s;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        /* Estilos do Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            z-index: 1000;
            /* Garante respiro nas bordas e respeita √°reas seguras (iOS) */
            padding: env(safe-area-inset-top, 0) env(safe-area-inset-right, 0) env(safe-area-inset-bottom, 0) env(safe-area-inset-left, 0);
            padding-left: max(8px, env(safe-area-inset-left));
            padding-right: max(8px, env(safe-area-inset-right));
            padding-top: max(8px, env(safe-area-inset-top));
            padding-bottom: max(8px, env(safe-area-inset-bottom));
            overflow: auto; /* Permite ver o modal completo em notebooks sem rolagem interna */
        }
        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background: white;
            padding: 2rem;
            border-radius: 0.75rem;
            text-align: center;
            transform: scale(0.9);
            transition: transform 0.3s ease;
            width: 90%;
            max-width: 700px; /* Ligeiramente menor para notebooks */
            /* Sem rolagem interna por padr√£o em desktops/tablets */
            max-height: none;
            overflow: visible;
            /* Destaque sutil das bordas em iPhone */
            border: 1px solid rgba(0,0,0,0.08);
            box-shadow: 0 12px 32px rgba(0,0,0,0.2);
        }
        .modal-overlay.visible .modal-content {
            transform: scale(1);
        }

        /* Estilos para o modal de "Pr√≥ximo Jogo" */
        .modal-overlay.next-game-style {
            align-items: flex-start;
            padding-top: 10vh;
            background: transparent; /* Remove o fundo escuro para melhor visualiza√ß√£o */
        }
        .modal-overlay.next-game-style .modal-content {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(8px);
        }
        .modal-overlay.next-game-style .modal-content button { background-color: #1f2937; color: white; }
        .modal-overlay.next-game-style .modal-content button:hover { background-color: #374151; }

        /* === RESPONSIVIDADE MOBILE-FIRST === */

        /* Controles do rodap√© */
        .controls-container {
            display: flex; 
            flex-wrap: wrap; /* Permite que os bot√µes quebrem a linha */
            align-items: center;
        }

        /* Em telas pequenas (mobile), os controles ficam em coluna */
        @media (max-width: 480px) {
            .controls-container {
                flex-direction: column;
                gap: 0.5rem;
            }
            .controls-container > div {
                justify-content: center;
                width: 100%;
            }
            /* Nudge fino: alinha verticalmente a√ß√µes com os contadores */
            #top-actions { margin-top: 20px; }
            /* Modal mais compacto em celulares */
            .modal-content {
                width: 94vw;
                max-width: none;
                padding: 1rem;
                border-radius: 0.75rem;
                max-height: 90vh;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
            /* Reduz imagem e t√≠tulos do modal Como Jogar em telas pequenas */
            #how-to-play-modal .modal-content img {
                width: 72px;
                height: auto;
            }
            #how-to-play-modal .modal-content h2 {
                font-size: 1.25rem; /* ~text-xl */
            }
            #how-to-play-modal .modal-content p,
            #how-to-play-modal .modal-content li {
                font-size: 0.95rem;
            }
            /* Compactar a caixa de pontua√ß√£o em celulares para caber o novo item */
            #how-to-play-modal [role="alert"] { padding: 0.5rem; }
            #how-to-play-modal [role="alert"] .text-lg { font-size: 1.1rem; }
            #how-to-play-modal [role="alert"] ul { margin-top: 0.25rem; }
            #how-to-play-modal [role="alert"] li { margin: 0; }
            /* Timer acima de Tentativas no mobile (no canto direito) */
            #top-stats { flex-direction: column; align-items: flex-end; gap: 0.25rem; }
            #timer-display { font-size: 0.95rem; }
            #counters-row { display: flex; align-items: center; gap: 1rem; }
        }

        /* Tablet e telas maiores */
        @media (min-width: 768px) {
            .card {
                font-size: clamp(1rem, 2.5vw, 1.25rem);
            }
            .game-wrapper {
                padding: 2rem;
            }
        }
        /* Notebooks/desktops: deixar modal mais largo e reduzir espa√ßo vertical */
        @media (min-width: 1024px) {
            .modal-content { max-width: 780px; }
            #how-to-play-modal .modal-content img { width: 96px; margin-bottom: 0.25rem; }
        }
        @media (min-width: 768px) and (max-height: 900px) {
            .modal-content { padding-top: 1rem; padding-bottom: 1rem; }
            #how-to-play-modal .modal-content img { width: 96px; margin-bottom: 0.25rem; }
        }

        /* (removidos) Ajustes de posi√ß√£o dos bot√µes para manter alinhamento original */
        .card.hint-highlight {
            outline: 3px solid #3b82f6; /* blue-500 */
            outline-offset: 2px;
        }

        /* Estilo dourado do bot√£o de ranking (somente visual, sem mover) */
        #ranking-button {
            background: linear-gradient(135deg, #fde68a 0%, #fbbf24 45%, #f59e0b 100%) !important;
            color: #7c4d00 !important;
            box-shadow: inset 0 0 0 1px rgba(251, 191, 36, 0.55);
            transition: filter 150ms ease-in-out, box-shadow 150ms ease-in-out;
        }
        #ranking-button:hover {
            filter: brightness(1.05) saturate(1.02);
            box-shadow: inset 0 0 0 1px rgba(251, 191, 36, 0.7);
        }

        /* (revertido) estilos extras do bot√£o de ranking removidos */

        /* Telas interativas: muito largas e com pouca altura (ex.: Nest Hub) */
        @media (max-height: 600px) and (min-width: 800px) {
            .modal-content {
                padding: 1rem;
                max-height: 92vh; /* aproveita melhor a altura dispon√≠vel */
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
            #how-to-play-modal .modal-content img {
                width: 80px;
            }
        }
        
        /* Ranking: Corrida (pista √∫nica com cen√°rio) */
        .race-stage {
            position: relative;
            width: 100%;
            height: 160px;
            border-radius: 18px;
            overflow: hidden;
            box-shadow: inset 0 0 0 1px #e5e7eb;
            background: linear-gradient(180deg, #cfe8ff 0%, #eaf4ff 65%, #b6d7a8 66%, #a5cf9b 100%);
        }
        .race-layer { position: absolute; inset: 0; pointer-events: none; }
        /* Cidade ao fundo */
        .race-city { background:
            repeating-linear-gradient(
              90deg,
              rgba(147,197,253,0.35) 0 24px,
              rgba(147,197,253,0.5) 24px 48px
            );
            opacity: .6;
            transform: translateZ(0);
            animation: cityMove 12s linear infinite;
        }
        @keyframes cityMove { from { background-position-x: 0; } to { background-position-x: -240px; } }
        /* Grama/hills no meio */
        .race-hills { top: 60%; height: 40%; background:
            repeating-linear-gradient(
              90deg,
              rgba(34,197,94,0.25) 0 30px,
              rgba(34,197,94,0.35) 30px 60px
            );
            animation: hillsMove 6s linear infinite;
        }
        @keyframes hillsMove { from { background-position-x: 0; } to { background-position-x: -180px; } }
        /* Estrada */
        .race-road { position: absolute; left: 0; right: 0; bottom: 0; height: 56px; background: #2f3035; z-index: 1; }
        .race-road::before { content: ''; position: absolute; left: 0; right: 0; top: 26px; height: 4px; background:
            repeating-linear-gradient(90deg, #ffffff 0 30px, transparent 30px 60px);
            opacity: 0.9; animation: roadMove 1.1s linear infinite; }
        @keyframes roadMove { from { background-position-x: 0; } to { background-position-x: -120px; } }
        /* Corredores */
        .race-runners { position: absolute; left: 0; right: 0; bottom: 0; top: 28px; z-index: 2; }
        .race-runner { position: absolute; left: 0; bottom: 2px; transition: left 1.2s ease-out; z-index: 2; display: flex; flex-direction: column-reverse; align-items: center; gap: 2px; }
        .runner-gif { width: 50px; height: 50px; object-fit: contain; }
        .runner-visual { display:inline-block; animation: bob 0.6s ease-in-out infinite alternate; }
        /* Tablets: todos os nomes (labels) brancos com borda preta mais vis√≠vel; GIFs inalterados
           Ampliado para incluir iPads em 1024px (paisagem) */
        @media (min-width: 768px) and (max-width: 1200px) {
            #ranking-modal .race-runners .runner-label {
                color: white !important;
                background: transparent !important;
                border: none !important;
                text-shadow: 0 0 3px black, 0 0 3px black, 0 0 3px black, 0 0 3px black !important;
                font-size: 10.5px !important; /* Aumenta um pouco o texto */
                max-width: none !important; /* Remove o limite de largura para evitar corte */
            }
            /* Tablets: zumbi menor com maior especificidade para sobrepor ajustes gerais */
            #ranking-modal .race-runners .runner-gif[src$="zumbi.gif"] {
                width: 32px !important;
                height: 32px !important;
            }
        }
        @keyframes bob { from { transform: translateY(-2px); } to { transform: translateY(2px); } }
        .runner-label { position: static; transform: none; z-index: 3; pointer-events: none; font-size: 9.5px; white-space: nowrap; background: rgba(255,255,255,0.95); padding: 1px 4px; border-radius: 9999px; border:1px solid #e5e7eb; box-shadow: 0 1px 3px rgba(0,0,0,0.08); max-width: 90px; overflow: hidden; text-overflow: ellipsis; }
        .runner-label.z2 { margin-bottom: 6px; }
        @media (max-width: 480px) { .runner-label { max-width: 56px; font-size: 8px; padding: 1px 3px; } }
        @media (min-width: 768px) and (max-width: 1023px) { .runner-label { max-width: 84px; font-size: 9px; } .runner-label.z2 { margin-bottom: 6px; } }
        @media (min-width: 1024px) { .runner-label { max-width: 90px; font-size: 9.5px; } .runner-label.z2 { margin-bottom: 8px; } }
        @media (max-width: 480px) { .race-stage { height: 125px; } .runner-gif { width: 44px; height: 44px; } .runner-label { font-size: 10px; } }
        @media (min-width: 768px) { .race-stage { height: 165px; } .runner-gif { width: 56px; height: 56px; } }
        @media (min-width: 1024px) { .race-stage { height: 185px; } .runner-gif { width: 60px; height: 60px; } }

        /* Ajustes finos por personagem (corrida) */
        .runner-gif[src$="policia.gif"]{ width: 94px !important; height: 94px !important; }
        .runner-gif[src$="rica.gif"]{ width: 84px !important; height: 84px !important; }
        .runner-gif[src$="menina.gif"]{ width: 94px !important; height: 94px !important; }
        .runner-gif[src$="corredor_frio.gif"]{ width: 84px !important; height: 84px !important; }
        .runner-gif[src$="corredor.gif"] { width: 84px !important; height: 84px !important; }
        .runner-gif[src$="zumbi.gif"] { width: 46px !important; height: 46px !important; }

        /* Desce levemente os que foram aumentados para n√£o sair da pista */
        .race-runner:has(.runner-gif[src$="policia.gif"]),
        .race-runner:has(.runner-gif[src$="rica.gif"]),
        .race-runner:has(.runner-gif[src$="menina.gif"]),
        .race-runner:has(.runner-gif[src$="corredor_frio.gif"]),
        .race-runner:has(.runner-gif[src$="corredor.gif"]) {
            transform: translateY(12px);
        }

        /* Tablet estreito: 768‚Äì820px ‚Äî reduzir personagens e nomes para caber */
        @media (min-width: 768px) and (max-width: 820px) {
            .race-stage { height: 138px; }
            .runner-gif { width: 36px; height: 36px; }
            .runner-gif[src$="policia.gif"],
            .runner-gif[src$="rica.gif"],
            .runner-gif[src$="menina.gif"],
            .runner-gif[src$="corredor_frio.gif"],
            .runner-gif[src$="corredor.gif"] { width: 40px !important; height: 40px !important; }
            .race-runner:has(.runner-gif[src$="policia.gif"]),
            .race-runner:has(.runner-gif[src$="rica.gif"]),
            .race-runner:has(.runner-gif[src$="menina.gif"]),
            .race-runner:has(.runner-gif[src$="corredor_frio.gif"]),
            .race-runner:has(.runner-gif[src$="corredor.gif"]) { transform: translateY(8px); }
            .runner-label { font-size: 6.2px; max-width: 38px; padding: 0 1px; letter-spacing: -0.1px; }
            .runner-label.z2 { margin-bottom: 4px; }
        }

        /* Celular: esconda o bot√£o de Corrida */
        @media (max-width: 767px) { #ranking-view-race { display: none; } }

        /* Ranking modal largura maior em telas grandes */
        #ranking-modal .modal-content { max-width: 720px; }
        @media (min-width: 768px) { #ranking-modal .modal-content { max-width: 820px; } }
        @media (min-width: 1024px) { #ranking-modal .modal-content { max-width: 960px; } }
        @media (prefers-reduced-motion: reduce) {
            .race-runner { transition: none; }
        }

        /* Lista: permitir Top 50 com rolagem suave dentro do modal */
        #ranking-modal #ranking-list.list-mode {
            max-height: 60vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding-right: 6px; /* espa√ßo para a barra de rolagem */
        }
        @media (max-width: 480px) {
            #ranking-modal #ranking-list.list-mode { max-height: 66vh; }
        }
        @media (min-width: 768px) and (max-width: 1023px) {
            #ranking-modal #ranking-list.list-mode { max-height: 58vh; }
        }

        /* Scroll para a lista do ranking quando for Top 50 */
        #ranking-list {
            max-height: 400px; /* Altura m√°xima antes de mostrar a barra de rolagem */
            overflow-y: auto;
            padding-right: 8px; /* Espa√ßo para a barra de rolagem */
        }
        
        /* Bal√£o de fala para o resumo do placar no submit */
        .speech-bubble {
            position: relative;
            background: #f3f4f6; /* gray-100 */
            border: 1px solid #e5e7eb; /* gray-200 */
            border-radius: 0.5rem;
            padding: 0.75rem;
        }
        .speech-bubble::before {
            content: '';
            position: absolute;
            left: -8px; /* aponta para o Jean √† esquerda em telas grandes */
            top: 14px;
            width: 0; height: 0;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            border-right: 8px solid #e5e7eb; /* borda */
        }
        .speech-bubble::after {
            content: '';
            position: absolute;
            left: -6px;
            top: 15px;
            width: 0; height: 0;
            border-top: 7px solid transparent;
            border-bottom: 7px solid transparent;
            border-right: 7px solid #f3f4f6; /* fundo */
        }
        /* Em mobile tamb√©m mostramos o rabicho para apontar para o Jean √† esquerda */
        /* (revertido) sem overrides de alinhamento mobile para os controles superiores */
        
        /* Espa√ßamento extra dos bot√µes flutuantes em tablets e celulares */
        @media (min-width: 768px) and (max-width: 1023px) {
            #floating-actions-right { bottom: 0.5rem; }
            #ranking-button { bottom: 0.5rem; }
            #streak-button { bottom: 0.5rem; }
        }
        @media (max-width: 767px) {
            #floating-actions-right { bottom: calc(max(0.25rem, env(safe-area-inset-bottom))); }
            #ranking-button { bottom: calc(max(0.25rem, env(safe-area-inset-bottom))); }
            #streak-button { bottom: calc(max(0.25rem, env(safe-area-inset-bottom))); }
        }

        /* Streak button states */
        #streak-button.streak-on {
            background: linear-gradient(135deg, #fde68a 0%, #fbbf24 45%, #f59e0b 100%);
            color: #7c4d00;
            box-shadow: inset 0 0 0 1px rgba(251, 191, 36, 0.55);
        }
        #streak-button .streak-icon.off { filter: grayscale(1) brightness(0.9); opacity: 0.7; }
    </style>
</head>
<body class="flex flex-col items-center justify-center md:justify-start min-h-screen p-2 sm:p-4">

    <div class="w-full max-w-xl md:max-w-2xl lg:max-w-4xl mx-auto">
        <header class="text-center mb-6">
            <h1 class="text-4xl md:text-5xl font-extrabold" style="text-shadow: 2px 2px 4px rgba(0,0,0,0.3);">Conexo</h1>
            <p id="game-subtitle" class="text-lg md:text-xl opacity-90">Crie quatro grupos de quatro!</p>
            <div class="text-sm md:text-base opacity-80 mt-1">
                <span>3 jogos di√°rios</span> &bull; <span id="current-date"></span>
            </div>
        </header>

        <main id="game-container" class="w-full game-wrapper relative pb-16">
            <!-- Grupos resolvidos aparecer√£o aqui -->
            <div id="solved-groups-container" class="mb-4 space-y-2"></div>
            
            <!-- Novos Controles Superiores -->
            <div class="flex justify-between items-center mb-4 text-sm font-semibold flex-wrap gap-y-2">
                <div id="top-actions" class="flex items-center gap-2">
                    <button id="give-up-button" class="text-red-500 hover:text-red-400 font-bold transition-colors">Desistir</button>
                    <button id="hint-button" class="px-3 py-1 bg-violet-500 text-white rounded-full hover:bg-violet-600 transition-colors">üí° Dica</button>
                </div>
                <div id="top-stats" class="flex items-center gap-4 text-gray-700">
                    <button id="timer-visibility-toggle" class="text-gray-400 hover:text-violet-600 focus:outline-none text-xs sm:text-sm" title="Mostrar tempo" aria-pressed="false">‚è±Ô∏è Mostrar</button>
                    <div id="timer-display" class="hidden">Tempo: <span id="timer-text">00:00</span></div>
                    <div id="counters-row" class="flex items-center gap-4">
                        <div>Dicas: <span id="hints-used-counter">0</span></div>
                        <div>Tentativas: <span id="attempts-counter">0</span></div>
                    </div>
                </div>
            </div>

            <!-- Grid do Jogo -->
            <div id="game-board" class="grid grid-cols-4 gap-2 md:gap-3 mb-4">
                <!-- Palavras s√£o inseridas aqui via JS -->
            </div>

            <!-- Controles Inferiores -->
            <div class="controls-container justify-center">
                <div class="flex space-x-2">
                    <button id="shuffle-button" class="px-3 py-2 bg-gray-200 text-gray-700 rounded-md font-semibold hover:bg-gray-300 transition-colors">Misturar</button>
                    <button id="deselect-button" class="px-3 py-2 bg-gray-200 text-gray-700 rounded-md font-semibold hover:bg-gray-300 transition-colors">Limpar</button>
                    <button id="submit-button" class="px-4 py-2 bg-gray-800 text-white rounded-md font-semibold transition-colors disabled:bg-gray-500 disabled:cursor-not-allowed hover:bg-gray-700">Enviar</button>
                </div>
            </div>

            <div id="floating-actions-right" class="absolute bottom-3 right-4 flex items-center gap-2">
                <button id="how-to-play-open-button" class="px-4 py-2 bg-violet-600 text-white rounded-md font-semibold hover:bg-violet-700 transition-colors" aria-label="Como Jogar">Como Jogar</button>
                <button id="credits-button" class="w-12 h-12 bg-gray-200 rounded-full flex items-center justify-center text-gray-600 hover:bg-gray-300 transition-colors shrink-0" aria-label="Cr√©ditos">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                    </svg>
                </button>
            </div>
            <button id="ranking-button" class="absolute bottom-3 left-4 w-12 h-12 bg-gray-200 rounded-full flex items-center justify-center text-gray-600 hover:bg-gray-300 transition-colors text-2xl" aria-label="Ranking">üèÜ</button>
            <button id="streak-button" class="absolute bottom-3 left-20 h-12 px-3 bg-gray-200 rounded-full flex items-center gap-2 text-gray-700 hover:bg-gray-300 transition-colors" aria-label="Sequ√™ncia">
                <span class="streak-icon text-2xl">üî•</span>
                <span id="streak-count" class="text-base font-semibold">0</span>
            </button>
        </main>
    </div>

    <!-- Modal para mensagens de vit√≥ria/derrota -->
    <div id="modal" class="modal-overlay">
        <div class="modal-content text-gray-800">
            <h2 id="modal-title" class="text-2xl font-bold mb-2"></h2>
            <p id="modal-message" class="mb-4 text-gray-600"></p>
            <div id="modal-results" class="space-y-1 mb-6"></div>
            <button id="modal-close-button" class="w-full px-4 py-2 bg-gray-800 text-white rounded-md font-semibold hover:bg-gray-700 transition-colors">Pr√≥ximo Jogo</button>
        </div>
    </div>

    <!-- Modal para Como Jogar -->
    <div id="how-to-play-modal" class="modal-overlay">
        <div class="modal-content text-gray-800">
            <img src="../src/assets/images/Jean_abre-bracos.gif" alt="Personagem Jean explicando o jogo" class="w-32 h-auto mx-auto mb-2">
            <h2 class="text-2xl font-bold mb-2">Como Jogar Conexo</h2>
            <p class="text-gray-600 mb-4">
                Seu objetivo √© encontrar <strong>4 grupos de 4 palavras</strong> que tenham algo em comum.
            </p>
            
            <div class="text-left space-y-2 text-gray-700 mb-6">
                <p><strong>1. Selecione</strong> quatro palavras que voc√™ acha que formam um grupo.</p>
                <p><strong>2. Envie</strong> para verificar. Se acertar, o grupo √© revelado!</p>
                <p><strong>3. Use Dicas</strong> se precisar de uma ajudinha para encontrar um grupo.</p>
            </div>

            <!-- Dicas de Pontua√ß√£o -->
            <div class="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-800 p-4 rounded-r-lg" role="alert">
                <p class="font-bold text-lg">‚ö†Ô∏è Aten√ß√£o na Pontua√ß√£o! ‚ö†Ô∏è</p>
                <p class="mt-2">Para fazer mais pontos, seja r√°pido e preciso!</p>
                <ul class="list-disc list-inside mt-2 space-y-1">
                    <li>Cada <strong>tentativa errada</strong> custa <strong class="text-red-600">-150 pontos</strong>.</li>
                    <li>Usar uma <strong>dica</strong> custa <strong class="text-red-600">-500 pontos</strong>.</li>
                    <li><strong>Tempo</strong>: a cada segundo s√£o <strong class="text-red-600">-5 pontos</strong>.</li>
                </ul>
            </div>

            <button id="how-to-play-close-button" class="mt-6 w-full px-4 py-2 bg-violet-600 text-white rounded-md font-semibold hover:bg-violet-700 transition-colors">Entendi, vamos jogar!</button>
        </div>
    </div>

    <!-- Modal para Cr√©ditos -->
    <div id="credits-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-xl font-bold mb-2">Cr√©ditos</h2>
            <p class="text-gray-600 mb-4">Ferramenta Educacional - Jogo Conexo</p>
            <p class="text-gray-800 font-semibold">Cria√ß√£o e desenvolvimento por Jo√£o Jr</p>
            <button id="credits-modal-close-button" class="mt-6 w-full px-4 py-2 bg-gray-800 text-white rounded-md font-semibold hover:bg-gray-700 transition-colors">Fechar</button>
        </div>
    </div>

    <!-- Modal para Ranking -->
    <div id="ranking-modal" class="modal-overlay">
        <div class="modal-content text-gray-800 w-full max-w-md">
            <h2 class="text-xl font-bold mb-4">üèÜ Ranking üèÜ</h2>
            <div class="flex border-b border-gray-200 mb-4">
                <button id="daily-ranking-tab" class="py-2 px-6 font-semibold text-gray-500 border-b-2 border-transparent hover:text-violet-600 hover:border-violet-600 focus:outline-none transition-colors">Di√°rio</button>
                <button id="weekly-ranking-tab" class="py-2 px-6 font-semibold text-gray-500 border-b-2 border-transparent hover:text-violet-600 hover:border-violet-600 focus:outline-none transition-colors">Semanal</button>
            </div>
            <p id="ranking-info" class="text-sm text-gray-600 mb-2 hidden">Ranking semanal: m√©dia das pontua√ß√µes di√°rias, de domingo a s√°bado.</p>
            <ul id="ranking-list" class="text-left space-y-2 min-h-[100px]">
                <!-- O ranking ser√° preenchido aqui -->
            </ul>
            <div class="mt-3 flex justify-center gap-2">
                <button id="ranking-view-list" class="py-1 px-3 text-sm font-semibold text-gray-600 bg-gray-100 rounded hover:bg-gray-200 focus:outline-none">Lista</button>
                <button id="ranking-view-race" class="py-1 px-3 text-sm font-semibold text-gray-600 bg-gray-100 rounded hover:bg-gray-200 focus:outline-none">Corrida</button>
            </div>
            <button id="ranking-modal-close-button" class="mt-6 w-full px-4 py-2 bg-gray-800 text-white rounded-md font-semibold hover:bg-gray-700 transition-colors">Fechar</button>
        </div>
    </div>

    <!-- Modal para Streak / Ofensivas -->
    <div id="streak-modal" class="modal-overlay">
        <div class="modal-content text-gray-800">
            <h2 class="text-xl font-bold mb-2">üî• Sequ√™ncia</h2>
            <p class="text-gray-600 mb-4">Complete jogos diariamente para manter sua sequ√™ncia.</p>
            <div id="streak-week" class="mb-4">
                <!-- Semaninha gerada por JS -->
            </div>
            <div class="grid grid-cols-2 gap-4 text-center">
                <div>
                    <div id="streak-current" class="text-2xl font-extrabold">0 dias</div>
                    <div class="text-gray-600">Sequ√™ncia atual</div>
                </div>
                <div>
                    <div id="streak-best" class="text-2xl font-extrabold">0 dias</div>
                    <div class="text-gray-600">Melhor sequ√™ncia</div>
                </div>
            </div>
            <button id="streak-modal-close-button" class="mt-6 w-full px-4 py-2 bg-gray-800 text-white rounded-md font-semibold hover:bg-gray-700 transition-colors">Fechar</button>
        </div>
    </div>

    <!-- Modal para Submeter Score -->
    <div id="submit-score-modal" class="modal-overlay">
        <div class="modal-content text-gray-800">
            <h2 class="text-xl font-bold mb-1">üéâ Fim de Jogo! üéâ</h2>
            <p class="text-gray-600 mb-3">Voc√™ completou os 3 jogos de hoje. Veja seu desempenho e entre para o ranking!</p>

            <div class="flex items-start gap-3 mb-3">
                <img src="../src/assets/images/Jean_abre-bracos.gif" alt="Jean comemorando seu resultado" class="w-16 h-auto md:w-24 select-none" draggable="false">
                <div class="speech-bubble flex-1">
                    <div id="score-summary" class="text-left space-y-1"></div>
                </div>
            </div>

            <div class="flex items-center gap-3 mb-2">
                <div class="flex items-center gap-2">
                    <span class="text-sm text-gray-600">Avatar:</span>
                    <span id="selected-avatar" class="text-2xl" title="Seu avatar">üèÉ‚Äç‚ôÇÔ∏è</span>
                </div>
                <button id="change-avatar-button" class="ml-auto px-2 py-1 text-sm rounded bg-gray-100 hover:bg-gray-200 text-gray-700">Escolher avatar</button>
            </div>
            <div id="avatar-picker" class="hidden grid grid-cols-8 gap-2 p-2 bg-gray-50 rounded border mb-2"></div>
            <input type="text" id="player-name-input" placeholder="Digite seu nome (m√°x. 15 caracteres)" maxlength="15" class="w-full p-2 border rounded-md mb-2 text-gray-800">
            <button id="submit-score-button" class="w-full px-4 py-2 bg-violet-600 text-white rounded-md font-semibold hover:bg-violet-700 transition-colors">Enviar para o Ranking</button>
            <button id="view-day-summary-button" class="mt-2 w-full px-4 py-2 bg-violet-100 text-violet-700 rounded-md font-semibold hover:bg-violet-200 transition-colors">Rever jogos de hoje</button>
            <button id="open-ranking-from-submit" class="mt-2 w-full px-4 py-2 bg-gray-800 text-white rounded-md font-semibold hover:bg-gray-700 transition-colors">Ver Ranking</button>
            <button id="submit-score-close-button" class="mt-2 w-full px-4 py-2 bg-gray-200 text-gray-800 rounded-md font-semibold hover:bg-gray-300 transition-colors">Fechar</button>
        </div>
    </div>

    <!-- Modal de resumo di√°rio -->
    <div id="daily-summary-modal" class="modal-overlay">
        <div class="modal-content text-gray-800 max-w-4xl">
            <h2 class="text-xl font-bold mb-1">Resumo dos jogos de hoje</h2>
            <p class="text-gray-600 mb-4">Confira como voc√™ foi em cada partida antes de enviar para o ranking.</p>
            <div id="daily-summary-content" class="space-y-3 max-h-[65vh] overflow-y-auto pr-2"></div>
            <button id="daily-summary-close-button" class="mt-6 w-full px-4 py-2 bg-gray-800 text-white rounded-md font-semibold hover:bg-gray-700 transition-colors">Fechar</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const puzzles = window.conexoPuzzles || [];



            const board = document.getElementById('game-board');
            const attemptsCounter = document.getElementById('attempts-counter');
            const solvedContainer = document.getElementById('solved-groups-container');
            const submitButton = document.getElementById('submit-button');
            const shuffleButton = document.getElementById('shuffle-button');
            const deselectButton = document.getElementById('deselect-button');
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalMessage = document.getElementById('modal-message');
            const modalResults = document.getElementById('modal-results');
            const modalCloseButton = document.getElementById('modal-close-button');
            const gameSubtitle = document.getElementById('game-subtitle');
            const hintsUsedCounter = document.getElementById('hints-used-counter');
            const hintButton = document.getElementById('hint-button');
            const giveUpButton = document.getElementById('give-up-button');
            const creditsButton = document.getElementById('credits-button');
            const creditsModal = document.getElementById('credits-modal');
            const creditsModalCloseButton = document.getElementById('credits-modal-close-button');
            const rankingButton = document.getElementById('ranking-button');
            const streakButton = document.getElementById('streak-button');
            const rankingModal = document.getElementById('ranking-modal');
            const rankingList = document.getElementById('ranking-list');
            const rankingModalCloseButton = document.getElementById('ranking-modal-close-button');
            const dailyRankingTab = document.getElementById('daily-ranking-tab');
            const weeklyRankingTab = document.getElementById('weekly-ranking-tab');
            const streakModal = document.getElementById('streak-modal');
            const streakModalCloseButton = document.getElementById('streak-modal-close-button');
            const streakWeekEl = document.getElementById('streak-week');
            const streakCurrentEl = document.getElementById('streak-current');
            const streakBestEl = document.getElementById('streak-best');
            const rankingInfoEl = document.getElementById('ranking-info');
            const submitScoreModal = document.getElementById('submit-score-modal');
            const scoreSummaryEl = document.getElementById('score-summary');
            const playerNameInput = document.getElementById('player-name-input');
            const avatarPicker = document.getElementById('avatar-picker');
            const changeAvatarButton = document.getElementById('change-avatar-button');
            const selectedAvatarEl = document.getElementById('selected-avatar');
            const howToPlayModal = document.getElementById('how-to-play-modal');
            const howToPlayCloseButton = document.getElementById('how-to-play-close-button');
            const howToPlayOpenButton = document.getElementById('how-to-play-open-button');

            const submitScoreButton = document.getElementById('submit-score-button');
            const submitScoreCloseButton = document.getElementById('submit-score-close-button');
            const openRankingFromSubmit = document.getElementById('open-ranking-from-submit');
            const rankingViewListBtn = document.getElementById('ranking-view-list');
            const rankingViewRaceBtn = document.getElementById('ranking-view-race');
            const dailySummaryButton = document.getElementById('view-day-summary-button');
            const dailySummaryModal = document.getElementById('daily-summary-modal');
            const dailySummaryCloseButton = document.getElementById('daily-summary-close-button');
            const dailySummaryContent = document.getElementById('daily-summary-content');

            // Timer elements
            const timerDisplay = document.getElementById('timer-display');
            const timerText = document.getElementById('timer-text');
            const timerToggleBtn = document.getElementById('timer-visibility-toggle');

            let selectedWords = [];
            let attempts = 0;
            let currentPuzzle;
            let foundGroups = [];
            let dailyPuzzles = [];
            let currentGameIndex = 0;
            let dailyProgress = { completed: [false, false, false], stats: [{a:0, h:0, t:0}, {a:0, h:0, t:0}, {a:0, h:0, t:0}] };
            let hintState = { groupCategory: null, revealedWords: [] };
            let hintsUsed = 0;
            let gameStartTime = 0;
            window.timerArmed = false;
            let rankingViewMode = localStorage.getItem('conexo-ranking-view') || 'list'; // 'list' | 'race'
            let cachedRankingData = null;
            const EMOJI_AVATARS = [];
            // 3 GIF runners 
            const GIF_AVATARS = [
                '/src/assets/avatars/menina.gif',
                '/src/assets/avatars/policia.gif',
                '/src/assets/avatars/cachorro.gif',
                '/src/assets/avatars/corredor.gif',
                '/src/assets/avatars/corredor_frio.gif',
                '/src/assets/avatars/gato.gif',
                '/src/assets/avatars/homem_linha.gif',
                '/src/assets/avatars/passaro.gif',
                '/src/assets/avatars/rica.gif',
                '/src/assets/avatars/zumbi.gif'
            ];
            // Mantemos Lottie apenas como reserva futura (n√£o usado por padr√£o)
            const LOTTIE_AVATARS = [];
            function simpleHash(str){ let h=0; for(let i=0;i<str.length;i++){ h=((h<<5)-h)+str.charCodeAt(i); h|=0; } return Math.abs(h); }
            const hasLottie = () => false; // desativado no momento
            function getLocalAvatarChoice(){
                const mode = localStorage.getItem('conexo-avatar-mode');
                const idx = Number(localStorage.getItem('conexo-avatar-index')||0);
                if (mode === 'gif') return { mode, index: idx, url: GIF_AVATARS[idx % GIF_AVATARS.length] };
                if (mode === 'emoji') return { mode, index: 0, char: 'üèÉ' };
                // retrocompatibilidade com antigo 'conexo-avatar' (emoji)
                const old = localStorage.getItem('conexo-avatar');
                if (old) return { mode: 'emoji', index: 0, char: old };
                // padr√£o: gif se existir, sen√£o emoji
                if (GIF_AVATARS.length) return { mode: 'gif', index: 0, url: GIF_AVATARS[0] };
                return { mode: 'emoji', index: 0, char: 'üèÉ' };
            }
            function setLocalAvatarGif(index){ localStorage.setItem('conexo-avatar-mode','gif'); localStorage.setItem('conexo-avatar-index', String(index)); renderSelectedAvatarPreview(); }
            function setLocalAvatarEmoji(index){ localStorage.setItem('conexo-avatar-mode','emoji'); localStorage.setItem('conexo-avatar-index', String(index)); renderSelectedAvatarPreview(); }
            function getVisualForName(name){
                const myName = localStorage.getItem('conexo-player-name');
                if (myName && name === myName) return getLocalAvatarChoice();
                const idx = simpleHash(name);
                if (GIF_AVATARS.length) return { mode: 'gif', index: idx % GIF_AVATARS.length, url: GIF_AVATARS[idx % GIF_AVATARS.length] };
                return { mode: 'emoji', index: 0, char: 'üèÉ' };
            }
            const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbzZCYw3e1bU3bA0L3zW36e-M6-5G390cWIyA-CFuKWzrvUTsTL34EySzvaqdJdE_R6t6Q/exec";

            const forbiddenWords = [
                // Palavr√µes comuns
                "caralho", "porra", "puta", "pqp", "vsf", "tnc", "merda", "bosta", "foder", "fuder",
                "cacete", "buceta", "krl", "pnc", "fdp", "viado", "baitola", "bixa", "arrombado",
                "corno", "chifrudo", "desgra√ßa", "desgraca", "inferno", "demonio", "capeta",
                // Ofensas e xingamentos
                "otario", "ot√°rio", "babaca", "idiota", "imbecil", "retardado", "mongol", "trouxa",
                "vagabundo", "vagabunda", "piranha", "prostituta", "canalha", "safado", "safada",
                "cretino", "escroto", "escrota", "cuz√£o", "cuzao", "filho da puta",
                // Termos racistas e discriminat√≥rios
                "preto", "nego", "negro", "macaco", "crioulo",
                "gordo", "gorda", "baleia",
                // Termos relacionados a atos sexuais de forma vulgar
                "boquete", "punheta", "siririca", "broxa", "gozar",
                // Outros termos de baixo cal√£o
                "cu", "pau", "pinto", "rola", "xoxota", "xota", "grelho", "rabao", "rabo",
                // Varia√ß√µes e abrevia√ß√µes
                "kct", "fudendo", "fodendo", "putaria", "viadinho", "bichona", "merdinha",
                // Termos que podem ser usados para bullying
                "feio", "feia", "horrivel", "nojento", "nojenta", "esquisito", "esquisita",
                // Apologia a coisas ilegais/ruins
                "hitler", "nazista", "nazi", "matar", "morrer", "suicidio", "drogas", "maconha", "cocaina"
            ];

            function setupDailyGames() {
                const today = new Date();
                const dateString = today.toISOString().split('T')[0];
                const dayOfYear = Math.floor((today - new Date(today.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24);
                
                const savedProgress = JSON.parse(localStorage.getItem(`conexo-progress-${dateString}`));
                if (savedProgress) {
                    dailyProgress = savedProgress;
                } else {
                     dailyProgress = { completed: [false, false, false], stats: [{a:0, h:0, t:0}, {a:0, h:0, t:0}, {a:0, h:0, t:0}] };
                     localStorage.setItem(`conexo-progress-${dateString}`, JSON.stringify(dailyProgress));
                }

                // 1. Separa os puzzles por dificuldade
                const easyPuzzles = puzzles.filter(p => p.difficulty === 1);
                const mediumPuzzles = puzzles.filter(p => p.difficulty === 2);
                const hardPuzzles = puzzles.filter(p => p.difficulty === 3);

                // 2. Seleciona um de cada, usando o dia do ano como semente para garantir consist√™ncia
                const dailyEasy = easyPuzzles[dayOfYear % easyPuzzles.length];
                const dailyMedium = mediumPuzzles[dayOfYear % mediumPuzzles.length];
                const dailyHard = hardPuzzles[dayOfYear % hardPuzzles.length];

                // 3. Monta a lista de jogos do dia e embaralha a ordem
                dailyPuzzles = [dailyEasy, dailyMedium, dailyHard];

                const dateEl = document.getElementById('current-date');
                if (dateEl) {
                    const today = new Date();
                    const options = { year: 'numeric', month: 'long', day: 'numeric' };
                    dateEl.textContent = today.toLocaleDateString('pt-BR', options);
                }

                const firstUnfinishedGame = dailyProgress.completed.indexOf(false);
                if (firstUnfinishedGame !== -1) {
                    currentGameIndex = firstUnfinishedGame;
                    // Mostra o modal "Como Jogar" toda vez que a p√°gina √© carregada e h√° um jogo para jogar.
                    showHowToPlayModal();
                    initGame(currentGameIndex, { autoStartTimer: false });
                } else {
                    // All games for today are completed
                    showAllGamesCompleted();
                }
            }
            
            function initGame(index, options = {}) {
                const { autoStartTimer = true } = options;
                currentGameIndex = index;
                gameSubtitle.textContent = `Jogo ${index + 1} de 3`;
                
                // Reset state
                selectedWords = [];
                attempts = 0;
                hintsUsed = 0;
                foundGroups = [];
                board.innerHTML = '';
                solvedContainer.innerHTML = '';
                board.style.pointerEvents = 'auto';
                hintState = { groupCategory: null, revealedWords: [] };

                // Reinicia o cron√¥metro conforme prefer√™ncia
                stopTimer();
                if (timerText) {
                    timerText.textContent = '00:00';
                }

                if (autoStartTimer) {
                    gameStartTime = Date.now();
                    window.gameStartTime = gameStartTime;
                    window.timerArmed = true;
                    if (getTimerPreference()) {
                        startTimer({ force: true });
                    }
                } else {
                    gameStartTime = 0;
                    window.gameStartTime = null;
                    window.timerArmed = false;
                }
                
                currentPuzzle = dailyPuzzles[index]; 
                let allWords = currentPuzzle.groups.flatMap(group => group.words);

                shuffleArray(allWords);
                allWords.forEach(word => {
                    const card = document.createElement('div');
                    card.textContent = word;
                    card.className = 'card text-center font-semibold uppercase bg-gray-200 text-gray-800 rounded-lg cursor-pointer';
                    card.addEventListener('click', () => handleCardClick(card));
                    board.appendChild(card);
                });

                attemptsCounter.textContent = attempts;
                hintsUsedCounter.textContent = hintsUsed;
                updateSubmitButton();
            }

            function handleCardClick(card) {
                const word = card.textContent;
                if (selectedWords.includes(word)) {
                    selectedWords = selectedWords.filter(w => w !== word);
                    card.classList.remove('selected');
                } else {
                    if (selectedWords.length < 4) {
                        selectedWords.push(word);
                        card.classList.add('selected');
                    }
                }
                updateSubmitButton();
            }

            function updateSubmitButton() {
                submitButton.disabled = selectedWords.length !== 4;
            }

            function handleSubmit() {
                if (selectedWords.length !== 4) return;

                const correctGroup = currentPuzzle.groups.find(group => 
                    arraysAreEqual(selectedWords, group.words)
                );

                if (correctGroup) {
                    foundGroups.push(correctGroup);

                    // Reset hint if the found group was solved
                    if (hintState.groupCategory === correctGroup.category) {
                        hintState = { groupCategory: null, revealedWords: [] };
                    }
                    
                    const solvedCard = document.createElement('div');
                    solvedCard.className = 'solved-card';
                    solvedCard.style.backgroundColor = correctGroup.color;
                    solvedCard.innerHTML = `<div class="font-bold">${correctGroup.category}</div><div class="solved-card-words">${correctGroup.words.join(', ')}</div>`;
                    solvedContainer.appendChild(solvedCard);

                    const remainingWords = Array.from(board.children)
                        .map(c => c.textContent)
                        .filter(w => !selectedWords.includes(w));
                    
                    board.innerHTML = '';
                    
                    remainingWords.forEach(word => {
                         const card = document.createElement('div');
                        card.textContent = word;
                        card.className = 'card text-center font-semibold uppercase bg-gray-200 text-gray-800 rounded-lg cursor-pointer';
                        card.addEventListener('click', () => handleCardClick(card));
                        board.appendChild(card);
                    });

                    selectedWords = [];
                    updateSubmitButton();
                    
                    if (foundGroups.length === 4) {
                        handleGameEnd(true);
                    }
                } else {
                    attempts++;
                    attemptsCounter.textContent = attempts;
                    
                    const selectedCards = Array.from(board.children).filter(c => selectedWords.includes(c.textContent));
                    selectedCards.forEach(c => c.classList.add('shake'));
                    setTimeout(() => selectedCards.forEach(c => c.classList.remove('shake')), 500);
                }
            }

            function handleGameEnd(isWin) {
                const elapsedTime = (Date.now() - gameStartTime) / 1000; // em segundos
                
                // Salva estat√≠sticas do jogo atual
                dailyProgress.completed[currentGameIndex] = true;
                dailyProgress.stats[currentGameIndex] = { a: attempts, h: hintsUsed, t: elapsedTime };

                dailyProgress.completed[currentGameIndex] = true;
                const today = new Date();
                const dateString = today.toISOString().split('T')[0];
                localStorage.setItem(`conexo-progress-${dateString}`, JSON.stringify(dailyProgress));

                const isAllGamesFinished = dailyProgress.completed.every(c => c === true);

                if (isAllGamesFinished) {
                    showSubmitScoreModal();
                } else if (isWin) {
                    showModal('Parab√©ns!', 'Voc√™ resolveu o quebra-cabe√ßa!');
                } else {
                    showModal('Desistiu?', 'Aqui est√£o as respostas corretas.', true);
                }
            }

            function shuffleBoardWords() {
                const remainingWords = Array.from(board.children).map(c => c.textContent);
                shuffleArray(remainingWords);
                board.innerHTML = '';
                remainingWords.forEach(word => {
                    const card = document.createElement('div');
                    card.textContent = word;
                    const isSelected = selectedWords.includes(word);
                    card.className = `card text-center font-semibold uppercase rounded-lg cursor-pointer ${isSelected ? 'selected' : 'bg-gray-200 text-gray-800'}`;
                    card.addEventListener('click', () => handleCardClick(card));
                    board.appendChild(card);
                });
            }
            
            function deselectAll() {
                 selectedWords = [];
                 Array.from(board.children).forEach(card => card.classList.remove('selected'));
                 updateSubmitButton();
            }

            function getHint() {
                const unsolvedGroups = currentPuzzle.groups.filter(g => !foundGroups.some(fg => fg.category === g.category));
                if (unsolvedGroups.length === 0) return;

                // If no group is being hinted, or the hinted group was solved, pick a new one
                if (!hintState.groupCategory || !unsolvedGroups.some(g => g.category === hintState.groupCategory)) {
                    hintState.groupCategory = unsolvedGroups[Math.floor(Math.random() * unsolvedGroups.length)].category;
                    hintState.revealedWords = [];
                }

                const groupToHint = unsolvedGroups.find(g => g.category === hintState.groupCategory);
                const wordToReveal = groupToHint.words.find(w => !hintState.revealedWords.includes(w));

                if (wordToReveal) {
                    hintsUsed++;
                    hintsUsedCounter.textContent = hintsUsed;

                    hintState.revealedWords.push(wordToReveal);
                    const cardToHighlight = Array.from(board.children).find(c => c.textContent === wordToReveal);
                    if (cardToHighlight) {
                        cardToHighlight.classList.add('hint-highlight');
                    }
                }
            }

            function giveUp() {
                handleGameEnd(false);
            }

            function showModal(title, message, showResults = false) {
                 modalTitle.textContent = title;
                 modalMessage.textContent = message;
                 modalResults.innerHTML = '';

                 if (showResults) {
                    modal.classList.remove('next-game-style');
                 } else {
                    modal.classList.add('next-game-style');
                 }

                 if (showResults) {
                     currentPuzzle.groups.forEach(group => {
                         if (!foundGroups.some(fg => fg.category === group.category)) {
                            const groupDiv = document.createElement('div');
                            groupDiv.className = 'p-2 rounded-md text-sm';
                            groupDiv.style.backgroundColor = group.color;
                            groupDiv.innerHTML = `<span class="font-bold">${group.category}:</span> ${group.words.join(', ')}`;
                            modalResults.appendChild(groupDiv);
                         }
                     });
                 }

                 const nextGameIndex = dailyProgress.completed.indexOf(false);
                 if (nextGameIndex !== -1) {
                     modalCloseButton.textContent = "Pr√≥ximo Jogo";
                 } else {
                     modalCloseButton.textContent = "Fim por hoje!";
                 }
                
                 modal.classList.add('visible');
            }

            function showAllGamesCompleted() {
                gameSubtitle.textContent = "Voc√™ completou todos os jogos de hoje!";
                board.innerHTML = `<div class="col-span-4 h-40 flex items-center justify-center text-lg font-semibold text-gray-500">Volte amanh√£ para mais desafios.</div>`;                
                document.querySelector('.controls-container').style.display = 'none';
            }
            
            modalCloseButton.addEventListener('click', () => {
                modal.classList.remove('visible', 'next-game-style');
                const nextGameIndex = dailyProgress.completed.indexOf(false);
                if (nextGameIndex !== -1) {
                    initGame(nextGameIndex);
                } else {
                    showAllGamesCompleted();
                }
            });

            // --- Event Listeners ---
            submitButton.addEventListener('click', handleSubmit);
            shuffleButton.addEventListener('click', shuffleBoardWords);
            deselectButton.addEventListener('click', deselectAll);
            hintButton.addEventListener('click', getHint);
            giveUpButton.addEventListener('click', giveUp);
            howToPlayOpenButton.addEventListener('click', showHowToPlayModal);
            const startGameTimerIfNeeded = () => {
                if (!timerText) return;
                if (!window.timerArmed) {
                    gameStartTime = Date.now();
                    window.gameStartTime = gameStartTime;
                    window.timerArmed = true;
                    if (getTimerPreference()) {
                        timerText.textContent = '00:00';
                        startTimer({ force: true });
                    }
                }
            };

            if (howToPlayCloseButton) {
                howToPlayCloseButton.addEventListener('click', () => {
                    closeHowToPlayModal();
                    startGameTimerIfNeeded();
                });
                howToPlayModal.addEventListener('click', (e) => {
                    if (e.target === howToPlayModal) {
                        closeHowToPlayModal();
                        startGameTimerIfNeeded();
                    }
                });
            }
            rankingButton.addEventListener('click', showRankingModal);
            if (streakButton) streakButton.addEventListener('click', showStreakModal);
            rankingModalCloseButton.addEventListener('click', () => rankingModal.classList.remove('visible'));
            dailyRankingTab.addEventListener('click', () => fetchAndDisplayRanking('daily'));
            weeklyRankingTab.addEventListener('click', () => fetchAndDisplayRanking('weekly'));
            submitScoreButton.addEventListener('click', submitScore);
            submitScoreCloseButton.addEventListener('click', () => submitScoreModal.classList.remove('visible'));
            if (openRankingFromSubmit) {
                openRankingFromSubmit.addEventListener('click', () => {
                    submitScoreModal.classList.remove('visible');
                    showRankingModal();
                });
            }
            if (dailySummaryButton && dailySummaryModal) {
                dailySummaryButton.addEventListener('click', () => {
                    renderDailySummary();
                    dailySummaryModal.classList.add('visible');
                });
                if (dailySummaryCloseButton) {
                    dailySummaryCloseButton.addEventListener('click', () => dailySummaryModal.classList.remove('visible'));
                }
                dailySummaryModal.addEventListener('click', (e) => {
                    if (e.target === dailySummaryModal) {
                        dailySummaryModal.classList.remove('visible');
                    }
                });
            }
            function renderSelectedAvatarPreview(){
                if (!selectedAvatarEl) return;
                const choice = getLocalAvatarChoice();
                selectedAvatarEl.innerHTML = '';
                if (choice.mode === 'gif') {
                    const img = document.createElement('img');
                    img.src = choice.url;
                    img.alt = 'Avatar';
                    img.className = 'avatar-gif';
                    img.style.width = '28px';
                    img.style.height = '28px';
                    img.style.objectFit = 'contain';
                    img.onerror = () => { selectedAvatarEl.textContent = 'üèÉ'; };
                    selectedAvatarEl.appendChild(img);
                } else {
                    selectedAvatarEl.textContent = choice.char || 'üèÉ';
                }
            }
            if (changeAvatarButton && avatarPicker && selectedAvatarEl) {
                renderSelectedAvatarPreview();
                changeAvatarButton.addEventListener('click', () => {
                    if (avatarPicker.classList.contains('hidden')) {
                        const gifGrid = GIF_AVATARS.map((u,i)=>`<button class="p-1 rounded hover:bg-gray-200" data-type="gif" data-index="${i}"><img src="${u}" alt="Avatar ${i+1}" style="width:36px;height:36px;object-fit:contain" onerror="this.style.display='none'"/></button>`).join('');
                        avatarPicker.innerHTML = gifGrid;
                        avatarPicker.classList.remove('hidden');
                    } else {
                        avatarPicker.classList.add('hidden');
                    }
                });
                avatarPicker.addEventListener('click', (e)=>{
                    const btn = e.target.closest('[data-type][data-index]');
                    if (!btn) return;
                    const type = btn.dataset.type; const idx = Number(btn.dataset.index);
                    if (type==='gif') setLocalAvatarGif(idx); else setLocalAvatarEmoji(idx);
                    avatarPicker.classList.add('hidden');
                });
            }
            if (rankingViewListBtn && rankingViewRaceBtn) {
                const syncViewButtons = () => {
                    const on = ['bg-violet-600','text-white'];
                    const off = ['bg-gray-100','text-gray-600'];
                    rankingViewListBtn.classList.remove(...on, ...off);
                    rankingViewRaceBtn.classList.remove(...on, ...off);
                    if (rankingViewMode==='list') { rankingViewListBtn.classList.add(...on); rankingViewRaceBtn.classList.add(...off); }
                    else { rankingViewRaceBtn.classList.add(...on); rankingViewListBtn.classList.add(...off); }
                };
                // Em celulares, for√ßa LISTA e esconde a op√ß√£o de Corrida
                const isMobile = window.matchMedia('(max-width: 767px)').matches;
                if (isMobile) {
                    rankingViewMode = 'list';
                    try { localStorage.setItem('conexo-ranking-view','list'); } catch {}
                    rankingViewRaceBtn.style.display = 'none';
                }
                rankingViewListBtn.addEventListener('click', ()=>{ rankingViewMode='list'; localStorage.setItem('conexo-ranking-view','list'); syncViewButtons(); if (cachedRankingData) renderRanking(cachedRankingData); });
                rankingViewRaceBtn.addEventListener('click', ()=>{ rankingViewMode='race'; localStorage.setItem('conexo-ranking-view','race'); syncViewButtons(); if (cachedRankingData) renderRanking(cachedRankingData); });
                syncViewButtons();
            }


            // --- Timer visibility toggle ---
            timerToggleBtn.addEventListener('click', () => {
                const newValue = !getTimerPreference();
                setTimerPreference(newValue);
                applyTimerVisibility();
            });

            // --- Helper Functions ---
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            function arraysAreEqual(arr1, arr2) {
                if (arr1.length !== arr2.length) return false;
                const sorted1 = [...arr1].sort();
                const sorted2 = [...arr2].sort();
                return sorted1.every((value, index) => value === sorted2[index]);
            }

            function showHowToPlayModal() {
                if (howToPlayModal) {
                    howToPlayModal.classList.add('visible');
                }
            }

            function closeHowToPlayModal() {
                if (howToPlayModal) {
                    howToPlayModal.classList.remove('visible');
                }
            }
            
            // --- Start Game ---
            setupDailyGames();
            applyTimerVisibility();
            // Atualiza o bot√£o de sequ√™ncia ap√≥s montar a tela
            try { if (streakButton) renderStreakButton(); } catch {}
            // Atalho de teste: abrir o modal de envio sem completar 3 jogos
            // Use ?testSubmit=1 ou #testSubmit na URL
            const url = new URL(window.location.href);
            if (url.searchParams.get('testSubmit') === '1' || window.location.hash === '#testSubmit') {
                // Inclui alguns n√∫meros fict√≠cios para visualiza√ß√£o
                dailyProgress = { completed: [true, true, true], stats: [{a:0,h:0,t:60},{a:1,h:2,t:120},{a:0,h:1,t:90}] };
                window.setTimeout(() => {
                    try { showSubmitScoreModal(); } catch (e) { console.warn('Teste submit modal:', e); }
                }, 300);
            }

            // Expoe atalho no console para testes manuais
            window.debugOpenSubmitScoreModal = () => { try { showSubmitScoreModal(); } catch (e) { console.error(e); } };

            // --- Ranking & Score Logic ---
            function calculateFinalScore() {
                const totalStats = dailyProgress.stats.reduce((acc, s) => {
                    acc.a += s.a;
                    acc.h += s.h;
                    acc.t += s.t;
                    return acc;
                }, { a: 0, h: 0, t: 0 });

                const baseScore = 30000;
                const attemptPenalty = totalStats.a * 150;
                const hintPenalty = totalStats.h * 500;
                const timePenalty = Math.floor(totalStats.t * 5); // 5 pontos por segundo

                const finalScore = Math.max(0, baseScore - attemptPenalty - hintPenalty - timePenalty);
                return { score: finalScore, stats: totalStats };
            }

            function showSubmitScoreModal() {
                const { score, stats } = calculateFinalScore();
                scoreSummaryEl.innerHTML = `
                    <div><strong>Pontua√ß√£o Final:</strong> <span class="text-green-600 font-bold">${score.toLocaleString('pt-BR')}</span></div>
                    <div><strong>Tentativas Totais:</strong> ${stats.a}</div>
                    <div><strong>Dicas Usadas:</strong> ${stats.h}</div>
                    <div><strong>Tempo Total:</strong> ${Math.floor(stats.t / 60)}m ${Math.floor(stats.t % 60)}s</div>
                `;
                submitScoreModal.classList.add('visible');
            }

            function renderDailySummary() {
                if (!dailySummaryContent) return;
                const labels = { 1: 'F√°cil', 2: 'M√©dio', 3: 'Dif√≠cil' };
                const stats = dailyProgress?.stats || [];
                const completed = dailyProgress?.completed || [];

                const formatDuration = (seconds) => {
                    if (!Number.isFinite(seconds)) return '--';
                    const total = Math.max(0, Math.round(seconds));
                    const mm = String(Math.floor(total / 60)).padStart(2, '0');
                    const ss = String(total % 60).padStart(2, '0');
                    return `${mm}:${ss}`;
                };

                const cards = [0, 1, 2].map((index) => {
                    const stat = stats[index] || { a: 0, h: 0, t: 0 };
                    const puzzle = dailyPuzzles[index];
                    if (!puzzle) return '';
                    const difficulty = labels[puzzle.difficulty] || `Jogo ${index + 1}`;
                    const status = completed[index] ? '‚úîÔ∏è Conclu√≠do' : '‚è≥ Em andamento';
                    const groupsMarkup = (puzzle.groups || []).map(group => `
                        <div class="solved-card" style="background-color: ${group.color || '#e5e7eb'};">
                            <div class="font-bold">${group.category}</div>
                            <div class="solved-card-words">${group.words.join(', ')}</div>
                        </div>
                    `).join('');

                    return `
                        <div class="border rounded-lg p-4 bg-gray-50 space-y-3">
                            <div class="flex items-center justify-between">
                                <h3 class="font-semibold text-gray-800">Jogo ${index + 1} ¬∑ ${difficulty}</h3>
                                <span class="text-sm">${status}</span>
                            </div>
                            <div class="grid grid-cols-3 gap-2 text-sm">
                                <div><span class="block text-gray-500">Tentativas</span><span class="font-semibold text-gray-800">${stat.a}</span></div>
                                <div><span class="block text-gray-500">Dicas</span><span class="font-semibold text-gray-800">${stat.h}</span></div>
                                <div><span class="block text-gray-500">Tempo</span><span class="font-semibold text-gray-800">${formatDuration(stat.t)}</span></div>
                            </div>
                            <div class="space-y-2">${groupsMarkup}</div>
                        </div>
                    `;
                });

                dailySummaryContent.innerHTML = cards.join('');
            }

            async function submitScore() {
                const name = playerNameInput.value.trim();
                if (!name) {
                    alert('Por favor, digite seu nome para entrar no ranking.');
                    return;
                }
                // Persistir nome e avatar localmente
                localStorage.setItem('conexo-player-name', name);
                if (!localStorage.getItem('conexo-avatar')) {
                    localStorage.setItem('conexo-avatar', 'üèÉ‚Äç‚ôÇÔ∏è');
                }

                // Verifica√ß√£o de palavras proibidas
                const lowerCaseName = name.toLowerCase();
                const isNameForbidden = forbiddenWords.some(word => lowerCaseName.includes(word));

                if (isNameForbidden) {
                    alert('Este nome n√£o √© permitido. Por favor, escolha outro.');
                    playerNameInput.value = ''; // Limpa o campo
                    return;
                }

                const { score } = calculateFinalScore();
                submitScoreButton.disabled = true;
                submitScoreButton.textContent = 'Enviando...';

                try {
                    await fetch(SCRIPT_URL, {
                        method: 'POST',
                        mode: 'no-cors', // Essencial para evitar erros de CORS com Google Scripts
                        // que √© compat√≠vel com o modo 'no-cors'.
                        body: JSON.stringify({ name, score })
                    });
                    alert('Pontua√ß√£o enviada com sucesso!');
                    submitScoreModal.classList.remove('visible');
                } catch (error) {
                    console.error('Erro ao enviar pontua√ß√£o:', error);
                    alert('Ocorreu um erro ao enviar sua pontua√ß√£o. Tente novamente.');
                } finally {
                    submitScoreButton.disabled = false;
                    submitScoreButton.textContent = 'Enviar para o Ranking';
                }
            }

            async function showRankingModal() {
                rankingModal.classList.add('visible');
                rankingList.innerHTML = '<li>Carregando ranking...</li>';
                try {
                    const response = await fetch(SCRIPT_URL);
                    const data = await response.json();

                    // --- DIAGN√ìSTICO ---
                    console.log("Resposta completa do servidor:", data);
                    console.log("Data que o servidor do Google est√° usando:", data.serverDate);
                    // --- FIM DIAGN√ìSTICO ---

                    const rankingData = data.ranking || []; // Pega a lista de ranking de dentro do objeto

                    rankingList.innerHTML = rankingData.map((entry, index) => 
                        `<li><span class="font-bold">${index + 1}.</span> ${entry.name} - <span class="text-green-600">${entry.score.toLocaleString('pt-BR')} pts</span></li>`
                    ).join('') || `<li class="text-center text-gray-500">Ningu√©m no ranking de hoje (${data.serverDate}). Seja o primeiro!</li>`;
                } catch (error) {
                    console.error('Erro ao buscar ranking:', error);
                    rankingList.innerHTML = '<li>Erro ao carregar o ranking. Verifique o console para mais detalhes.</li>';
                }
            }

            function showRankingModal() {
                rankingViewMode = 'list';
                try { localStorage.setItem('conexo-ranking-view','list'); } catch {}
                // Sincroniza bot√µes se existirem
                if (rankingViewListBtn && rankingViewRaceBtn) {
                    const on = ['bg-violet-600','text-white'];
                    const off = ['bg-gray-100','text-gray-600'];
                    rankingViewListBtn.classList.remove(...off);
                    rankingViewListBtn.classList.add(...on);
                    rankingViewRaceBtn.classList.remove(...on);
                    rankingViewRaceBtn.classList.add(...off);
                }
                rankingModal.classList.add('visible');
                fetchAndDisplayRanking('daily'); // Carrega o ranking di√°rio por padr√£o
            }

            async function fetchAndDisplayRanking(period) {
                // Atualiza o estilo da aba ativa
                const tabs = [dailyRankingTab, weeklyRankingTab];
                tabs.forEach(tab => {
                    tab.classList.remove('text-violet-600', 'border-violet-600');
                    tab.classList.add('text-gray-500', 'border-transparent');
                });
                const activeTab = (period === 'daily') ? dailyRankingTab : weeklyRankingTab;
                activeTab.classList.add('text-violet-600', 'border-violet-600');
                activeTab.classList.remove('text-gray-500', 'border-transparent');

                // Mostra explica√ß√£o curta quando estiver no semanal
                if (rankingInfoEl) {
                    if (period === 'weekly') {
                        rankingInfoEl.textContent = 'Ranking semanal: m√©dia das pontua√ß√µes di√°rias, de domingo a s√°bado.';
                        rankingInfoEl.classList.remove('hidden');
                    } else {
                        rankingInfoEl.classList.add('hidden');
                    }
                }

                rankingList.innerHTML = '<li>Carregando ranking...</li>';
                try {
                    const url = new URL(SCRIPT_URL);
                    url.searchParams.append('period', period);
                    url.searchParams.append('limit', '50'); // Pede ao servidor o Top 50

                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const data = await response.json();

                    const rankingData = data.ranking || [];
                    const dateInfo = data.serverDate || (period === 'daily' ? 'hoje' : 'esta semana');
                    const message = period === 'daily' ? `Ningu√©m no ranking de hoje (${dateInfo}). Seja o primeiro!` : `Ningu√©m no ranking desta semana. Seja o primeiro!`;
                    cachedRankingData = rankingData;
                    renderRanking(rankingData, message);
                } catch (error) {
                    console.error(`Erro ao buscar ranking ${period}:`, error);
                    rankingList.innerHTML = '<li>Erro ao carregar o ranking. Tente novamente mais tarde.</li>';
                }
            }

            function renderRanking(rankingData, emptyMessage='Sem dados'){
                // Avatar consistente por nome para Lista e Corrida
                const visualsMap = (function(){
                    const used = new Set();
                    const myName = localStorage.getItem('conexo-player-name');
                    const map = new Map();
                    rankingData.forEach(entry => {
                        if (myName && entry.name === myName) {
                            const v = getLocalAvatarChoice();
                            map.set(entry.name, v);
                            if (v && v.mode==='gif') used.add(v.index);
                            return;
                        }
                        if (GIF_AVATARS.length) {
                            let idx = simpleHash(entry.name) % GIF_AVATARS.length;
                            let tries = 0;
                            while (used.has(idx) && tries < GIF_AVATARS.length) { idx = (idx+1) % GIF_AVATARS.length; tries++; }
                            used.add(idx);
                            map.set(entry.name, { mode:'gif', index: idx, url: GIF_AVATARS[idx] });
                        } else {
                            map.set(entry.name, { mode:'emoji', index:0, char:'üèÉ' });
                        }
                    });
                    return map;
                })();
                if (rankingViewMode === 'list') {
                    // Ativa estilo de lista com rolagem (Top 50)
                    rankingList.classList.add('list-mode');
                    // Para a lista, usa Top 50
                    const list = rankingData.slice(0, 50);
                    const visuals = list.map(e => visualsMap.get(e.name) || getVisualForName(e.name)); 
                    rankingList.innerHTML = list.map((entry, index) => {
                        let positionHtml;
                        if (index === 0) {
                            positionHtml = '<span class="w-8 inline-block text-center text-2xl" title="1¬∫ Lugar">üëë</span>';
                        } else if (index === 1) {
                            positionHtml = '<span class="w-8 inline-block text-center text-xl" title="2¬∫ Lugar">ü•à</span>';
                        } else if (index === 2) {
                            positionHtml = '<span class="w-8 inline-block text-center text-xl" title="3¬∫ Lugar">ü•â</span>';
                        } else {
                            positionHtml = `<span class="w-8 inline-block text-center font-bold text-gray-500">${index + 1}.</span>`;
                        }
                        const visual = visuals[index] || getVisualForName(entry.name);
                        let avHtml;
                        if (visual.mode==='gif') {
                            avHtml = `<span class=\"w-8 inline-flex justify-center\"><img src=\"${visual.url}\" alt=\"avatar\" style=\"width:24px;height:24px;object-fit:contain\" onerror=\"this.outerHTML='üèÉ'\"></span>`;
                        } else {
                            avHtml = `<span class=\"w-8 inline-flex justify-center text-xl\">${visual.char || 'üèÉ'}</span>`;
                        }
                        return `<li class="flex items-center py-1">${positionHtml}${avHtml}<span class="ml-2">${entry.name} - <span class="text-green-600">${entry.score.toLocaleString('pt-BR')} pts</span></span></li>`;
                    }).join('') || `<li class="text-center text-gray-500">${emptyMessage}</li>`;
                    return;
                }
                // Race view (pista √∫nica, todos juntos)
                rankingList.classList.remove('list-mode');
                if (!rankingData.length) { rankingList.innerHTML = `<li class="text-center text-gray-500">${emptyMessage}</li>`; return; }
                const screenW = window.innerWidth || document.documentElement.clientWidth;
                const isTablet = screenW >= 768 && screenW <= 1023;
                const isTabletColor = screenW >= 768 && screenW <= 1200;
                const topCount = isTablet ? 8 : 10;
                // Para a corrida, limitamos aos 10 primeiros
                const top = rankingData.slice(0, topCount); 
                const maxScore = Math.max(...top.map(r=>r.score));
                const amp = 0; // manter todos na mesma linha
                const runnersHtml = top.map((entry, index) => {
                    const visual = visualsMap.get(entry.name) || getVisualForName(entry.name);
                    const posIcon = index===0?'üëë': index===1?'ü•à': index===2?'ü•â': (index+1)+'.';
                    const isNarrowTablet = screenW >= 768 && screenW <= 820;
                    // Alterna faixas: para tablets estreitos, aumenta um pouco a separa√ß√£o vertical
                    const isLowLane = (index % 2 === 0);
                    const laneBottom = isNarrowTablet ? (isLowLane ? 4 : 44) : (isLowLane ? 6 : 30);
                    let content;
                    if (visual.mode==='gif') {
                        content = `<img class=\"runner-gif runner-visual\" src=\"${visual.url}\" alt=\"avatar\" onerror=\"this.outerHTML='${EMOJI_AVATARS[0]}'\">`;
                    } else {
                        content = `<span class=\"text-3xl runner-visual\">${visual.char}</span>`;
                    }
                    const showLabel = screenW >= 768 || index < 3; // em mobile s√≥ Top 3
                    const zebraClass = (screenW >= 768 && index % 2 === 1) ? ' z2' : '';
                    const safeName = entry.name.replace(/</g,'&lt;').replace(/>/g,'&gt;');
                    // Em tablets, for√ßa nomes brancos com borda preta (todos os lanes)
                    const labelHtml = showLabel
                        ? `<div class="runner-label${zebraClass}" title="${safeName}"><span class="runner-label-text">${posIcon} ${safeName}</span></div>`
                        : '';
                    const laneClass = isLowLane ? ' low-lane' : '';
                    return `<div class=\"race-runner${laneClass}\" data-score=\"${entry.score}\" data-max=\"${maxScore}\" data-rank=\"${index}\" style=\"bottom:${laneBottom}px\">${content}${labelHtml}</div>`;
                }).join('');
                rankingList.innerHTML = `<li class=\"py-2\"><div class=\"race-stage\"><div class=\"race-layer race-city\"></div><div class=\"race-layer race-hills\"></div><div class=\"race-runners\">${runnersHtml}</div><div class=\"race-road\"></div></div></li>`;

                const positionRunners = () => {
                    const track = rankingList.querySelector('.race-stage');
                    if (!track) return;
                    const runners = Array.from(rankingList.querySelectorAll('.race-runner'));
                    const trackRect = track.getBoundingClientRect();
                    const screenW = window.innerWidth || document.documentElement.clientWidth;
                    const isNarrowTablet = screenW >= 768 && screenW <= 820;
                    // Em tablets estreitos, reduz o gap e aumente o padding direito
                    // para evitar acumular muito √† direita e garantir que todos caibam.
                    const baseMinGap = isNarrowTablet ? 52 : (screenW >= 1024 ? 90 : (screenW >= 768 ? 68 : 42));
                    const padding = isNarrowTablet ? 18 : 8; // mais margem √† direita em tablets
                    const leftPadding = screenW >= 1024 ? 16 : (screenW >= 768 ? 12 : 8); // margem esquerda
                    const count = runners.length;
                    const data = runners.map((r, idx) => {
                        const holder = r.querySelector('.runner-gif');
                        const totalWidth = r.getBoundingClientRect().width || 56; // inclui label
                        const gifWidth = holder ? (holder.getBoundingClientRect().width || 56) : 56;
                        const width = Math.max(totalWidth, gifWidth);
                        const score = Number(r.dataset.score)||0;
                        const max = Number(r.dataset.max)||1;
                        const rank = Number(r.dataset.rank ?? idx);
                        // Distribui√ß√£o: em tablets estreitos, priorize espa√ßamento uniforme por rank.
                        // Em outras telas, mantenha a curva por score.
                        let pct;
                        if (isNarrowTablet) {
                            // Frac√ß√£o por rank com margens (evita encostar nas bordas)
                            const frac = count > 1 ? (rank + 1) / (count + 1) : 0.5;
                            pct = Math.max(0.06, Math.min(0.94, frac));
                        } else {
                            // curva levemente n√£o-linear para espalhar quando scores s√£o pr√≥ximos
                            const basePct = max>0 ? Math.max(0.05, Math.min(1, score/max)) : 0;
                            const exponent = (screenW >= 1024 ? 0.88 : (screenW >= 768 ? 0.9 : 1.0));
                            pct = Math.pow(basePct, exponent);
                        }
                        const maxRight = trackRect.width - width - padding;
                        const desired = Math.max(0, Math.min(maxRight, maxRight * pct));
                        return { el: r, width, desired, maxRight, score, idx, rank };
                    });
                    // Posiciona em ordem de ranking por score (do pior para o melhor),
                    // garantindo que o 1¬∫ fique sempre mais √† direita.
                    const posArr = new Array(data.length).fill(0);
                    if (isNarrowTablet) {
                        // Posicionamento espec√≠fico para tablets estreitos:
                        // 1) ancora o 1¬∫ colocado na posi√ß√£o alvo √† direita
                        // 2) cada pr√≥ximo acompanha √† esquerda com espa√ßamento m√≠nimo
                        const orderBest = [...data].sort((a,b)=>b.score-a.score); // melhor -> pior
                        const usableWidth = trackRect.width - leftPadding - padding;
                        const stepPix = usableWidth / (count + 1);
                        let prevLeft = null;
                        for (let i=0; i<orderBest.length; i++) {
                            const d = orderBest[i];
                            const rankFromWorst = count - d.rank; // best => count, worst => 1
                            let target = leftPadding + rankFromWorst * stepPix;
                            const maxRight = d.maxRight; // j√° considera largura e padding
                            if (target > maxRight) target = maxRight;
                            let minGap = Math.max(40, d.width * 0.75);
                            let left = target;
                            if (prevLeft != null) {
                                left = Math.min(target, prevLeft - minGap);
                            }
                            left = Math.max(leftPadding, Math.min(left, maxRight));
                            posArr[d.idx] = left;
                            prevLeft = left;
                        }
                    } else {
                        // Demais telas: mant√©m l√≥gica de pior->melhor garantindo monotonia √† direita
                        const order = [...data].sort((a,b)=>a.score-b.score);
                        for (let i=0;i<order.length;i++) {
                            const prevLeft = i>0 ? posArr[order[i-1].idx] : null;
                            // Em telas largas use gap base proporcional
                            let minGap = Math.max(baseMinGap, order[i].width * 0.9);
                            const remaining = order.length - i - 1;
                            const spaceForRest = remaining * baseMinGap; // reserva m√≠nima para os pr√≥ximos
                            const maxAllowedHere = order[i].maxRight - spaceForRest;
                            const candidate = Math.min(order[i].desired, maxAllowedHere);
                            const minLeftThis = prevLeft==null ? leftPadding : (prevLeft + minGap);
                            const left = Math.max(candidate, minLeftThis);
                            posArr[order[i].idx] = Math.min(left, order[i].maxRight);
                        }
                    }
                    // Aplica posi√ß√µes
                    data.forEach(d => {
                        const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
                        if (prefersReduced) d.el.style.transition = 'none';
                        d.el.style.left = (posArr[d.idx] || d.desired) + 'px';
                    });
                };
                requestAnimationFrame(positionRunners);
                setTimeout(positionRunners, 400);
                // Recalcula ao redimensionar (especialmente √∫til em tablets rotacionando)
                window.addEventListener('resize', positionRunners, { passive: true });
            }

            // --- Credits Modal Logic ---
            creditsButton.addEventListener('click', () => {
                creditsModal.classList.add('visible');
            });
            creditsModalCloseButton.addEventListener('click', () => {
                creditsModal.classList.remove('visible');
            });
            creditsModal.addEventListener('click', (e) => {
                if (e.target === creditsModal) creditsModal.classList.remove('visible');
            });

            // === Streak logic ===
            function ymd(d){ return d.toISOString().slice(0,10); }
            function addDays(d, n){ const x = new Date(d); x.setDate(x.getDate()+n); return x; }
            function getCompletedDatesSet(){
                const set = new Set();
                try {
                    for (let i=0;i<localStorage.length;i++){
                        const k = localStorage.key(i);
                        if (!k || !k.startsWith('conexo-progress-')) continue;
                        const dateStr = k.substring('conexo-progress-'.length);
                        try {
                            const obj = JSON.parse(localStorage.getItem(k));
                            if (obj && Array.isArray(obj.completed) && obj.completed.length===3 && obj.completed.every(Boolean)) {
                                set.add(dateStr);
                            }
                        } catch {}
                    }
                } catch {}
                return set;
            }
            function getCurrentStreak(completed){
                let streak = 0; let d = new Date();
                for(;;){
                    const s = ymd(d);
                    if (completed.has(s)) { streak++; d = addDays(d,-1); } else { break; }
                }
                return streak;
            }
            function getBestStreak(completed){
                // varre √∫ltimos 180 dias para estimar melhor sequ√™ncia
                let best = 0; let cur = 0; let d = addDays(new Date(), -180);
                for (let i=0;i<=180;i++){
                    const s = ymd(d);
                    if (completed.has(s)) { cur++; best = Math.max(best, cur); } else { cur = 0; }
                    d = addDays(d,1);
                }
                return best;
            }
            function renderStreakButton(){
                const completed = getCompletedDatesSet();
                const todayDone = completed.has(ymd(new Date()));
                const current = getCurrentStreak(completed);
                const iconEl = streakButton.querySelector('.streak-icon');
                const countEl = document.getElementById('streak-count');
                if (todayDone) {
                    streakButton.classList.add('streak-on');
                    iconEl.classList.remove('off');
                } else {
                    streakButton.classList.remove('streak-on');
                    iconEl.classList.add('off');
                }
                countEl.textContent = String(current);
            }
            function renderStreakModal(){
                const completed = getCompletedDatesSet();
                const now = new Date();
                const dow = now.getDay(); // 0=Dom
                const start = addDays(new Date(now.getFullYear(), now.getMonth(), now.getDate()), -dow);
                const daysLabels = ['Do','2¬™','3¬™','4¬™','5¬™','6¬™','Sa'];
                let html = '<div class="flex items-center justify-between mb-1">';
                for (let i=0;i<7;i++){
                    const d = addDays(start, i);
                    const done = completed.has(ymd(d));
                    const isToday = ymd(d)===ymd(now);
                    const fire = done ? 'üî•' : '‚Ä¢';
                    const color = done ? 'text-orange-500' : 'text-gray-300';
                    html += `<div class=\"flex flex-col items-center w-10\"><div class=\"text-xl ${color}\">${fire}</div><div class=\"text-[11px] ${isToday?'font-bold text-gray-800':'text-gray-500'}\">${daysLabels[i]}</div></div>`;
                }
                html += '</div>';
                streakWeekEl.innerHTML = html;
                const cur = getCurrentStreak(completed);
                const best = getBestStreak(completed);
                streakCurrentEl.textContent = `${cur} ${cur===1?'dia':'dias'}`;
                streakBestEl.textContent = `${best} ${best===1?'dia':'dias'}`;
            }
            function showStreakModal(){
                if (!streakModal) return;
                renderStreakModal();
                streakModal.classList.add('visible');
            }
            if (streakModalCloseButton) {
                streakModalCloseButton.addEventListener('click', ()=> streakModal.classList.remove('visible'));
                streakModal.addEventListener('click', (e)=>{ if (e.target===streakModal) streakModal.classList.remove('visible'); });
            }


        });
    </script>
    <script>
        // Cron√¥metro utilit√°rios (isolados para clareza)
        (function(){
            const timerDisplay = document.getElementById('timer-display');
            const timerText = document.getElementById('timer-text');
            const timerToggleBtn = document.getElementById('timer-visibility-toggle');
            // Se elementos n√£o existem, n√£o prossegue (defesa)
            if (!timerDisplay || !timerText || !timerToggleBtn) return;

            // Integra com vari√°veis globais definidas acima
            let timerIntervalRef = null;
            if (typeof window.timerArmed === 'undefined') {
                window.timerArmed = false;
            }

            window.getTimerPreference = function() {
                try { return JSON.parse(localStorage.getItem('conexo-timer-visible') || 'false'); } catch { return false; }
            };

            window.setTimerPreference = function(value) {
                localStorage.setItem('conexo-timer-visible', JSON.stringify(!!value));
            };

            window.startTimer = function(options = {}) {
                const { force = false } = options;
                if (timerIntervalRef) return;
                if (!force && !window.timerArmed) return;
                if (!window.gameStartTime) {
                    window.gameStartTime = Date.now();
                }
                updateTimerText();
                timerIntervalRef = setInterval(updateTimerText, 1000);
            };

            window.stopTimer = function() {
                if (timerIntervalRef) {
                    clearInterval(timerIntervalRef);
                    timerIntervalRef = null;
                }
            };

            window.applyTimerVisibility = function() {
                const visible = getTimerPreference();
                timerToggleBtn.setAttribute('aria-pressed', String(visible));
                if (visible) {
                    timerDisplay.classList.remove('hidden');
                    timerToggleBtn.textContent = '‚è±Ô∏è Ocultar';
                    timerToggleBtn.title = 'Ocultar tempo';
                    startTimer();
                } else {
                    timerDisplay.classList.add('hidden');
                    timerToggleBtn.textContent = '‚è±Ô∏è Mostrar';
                    timerToggleBtn.title = 'Mostrar tempo';
                    stopTimer();
                }
            };

            function updateTimerText() {
                // Usa gameStartTime global do script principal
                const start = window.gameStartTime || Date.now();
                const elapsedSec = Math.max(0, Math.floor((Date.now() - start) / 1000));
                const mm = String(Math.floor(elapsedSec / 60)).padStart(2, '0');
                const ss = String(elapsedSec % 60).padStart(2, '0');
                timerText.textContent = `${mm}:${ss}`;
            }
        })();
    </script>

</body>
</html>
