<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <link rel="stylesheet" href="../src/css/global.css">
    <!-- Fonte Montserrat apenas para esta p√°gina -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;600;700&display=swap" rel="stylesheet">
    <title>Conte as Bolhas M√°gicas! ü´ß</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            user-select: none;
        }

        /* Container principal */
        #mainContainer {
            width: 90%;
            max-width: 1200px;
            height: 85vh;
            max-height: 800px;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Header com t√≠tulo */
        #header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 15px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        #activityTitle {
            font-size: 28px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }
        /* ======= Safe-area + unidades modernas ======= */
        :root{
        /* iOS safe area ‚Äì volta 0 se n√£o existir */
        --safe-bottom: env(safe-area-inset-bottom, 0px);
        --safe-top: env(safe-area-inset-top, 0px);
        /* fallback para o truque de 100vh via JS (ver se√ß√£o 3) */
        --app-vh: 100vh;
        }

        /* O body pode rolar em telas pequenas; antes estava hidden e cortava */
        @media (max-width: 768px){
        body{
            overflow-y: auto;
        }
        }

        /* Container principal: usar dvh (√°rea √∫til real) com fallbacks */
        #mainContainer{
        /* desktop mant√©m como est√°; em mobile use a √°rea √∫til real */
        height: 92dvh;                 /* browsers modernos (inclui iOS 16+ e Android) */
        height: calc(var(--app-vh) * 0.92); /* fallback JS p/ Safari antigo */
        max-height: none;
        /* espa√ßo para a barra do iPhone */
        padding-bottom: calc(var(--safe-bottom) + 12px);
        }

        /* √Årea do conte√∫do tamb√©m respeita safe area, evitando o corte do bot√£o */
        #contentArea{
        padding-bottom: calc(var(--safe-bottom) + 12px);
        overflow: hidden; /* o jogo n√£o rola; a p√°gina sim */
        }

        /* Menu inicial: garante que tudo caiba em telas baixinhas */
        @media (max-height: 700px){
        #menuTitle{ font-size: 24px; }
        #menuCharacter{ width: 90px; height: 115px; }
        #difficultySelector{ gap: 8px; }
        .difficultyBtn{ padding: 12px 22px; font-size: 18px; }
        #startBtn{ padding: 16px 40px; font-size: 24px; }
        }

        /* HUD e elementos no jogo menores em telas baixinhas */
        @media (max-height: 700px){
        #gameHUD{
            top: 8px;
            padding: 8px 14px;
            gap: 6px;
        }
        #targetDisplay{ font-size: 16px; }
        #counter{ font-size: 20px; }
        #progressBar{ width: 130px; height: 6px; }
        }

        /* A varinha (lupa) nunca encosta na barra do iPhone */
        #bubbleWand{
        bottom: calc(20px + var(--safe-bottom));
        }

        /* Bot√µes flutuantes no jogo: afastar do topo com notch */
        #gameControls{
        top: calc(12px + var(--safe-top));
        }

        /* Modal: d√° um respiro com a safe-area tamb√©m */
        #victoryModal .victoryContent{
        margin-bottom: var(--safe-bottom);
        }


        /* √Årea de conte√∫do */
        #contentArea {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        /* Menu inicial */
        #startMenu {
            position: absolute;
            width: 100%;
            height: 100%;
            background: transparent;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 500;
            transition: all 0.5s ease-out;
        }

        /* V√≠deo de fundo responsivo */
        .bg-video{
          position:absolute;
          inset:0;
          width:100%;
          height:100%;
          object-fit:cover;
          z-index:0;
          pointer-events:none;
        }

        /* V√©u para legibilidade do texto */
        .startMenu-overlay{
          position:absolute;
          inset:0;
          z-index:1;
          pointer-events:none;
          background: linear-gradient(
            180deg, 
            rgba(0,0,0,.10) 0%,
            rgba(255,255,255,.20) 50%,
            rgba(255,255,255,.35) 100%
          );
        }

        /* Conte√∫do do menu acima do v√≠deo */
        .startMenu-content{
          position:relative;
          z-index:2;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          padding: 0;
          background: transparent;
          border-radius: 0;
          box-shadow: none;
          max-width: 600px;
          margin-top: 20vh;
        }

        /* Esconder menu */
        #startMenu.hidden{
          opacity:0;
          pointer-events:none;
          transform:scale(.8);
          transition:all .5s ease-out;
        }

        #menuTitle {
            font-size: 42px;
            color: white;
            margin-bottom: 30px;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
            animation: floatTitle 3s ease-in-out infinite;
        }

        @keyframes floatTitle {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* Seletor de dificuldade */
        #difficultySelector {
            display: flex;
            gap: 20px;
            margin-bottom: 25px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .difficultyBtn {
            padding: 16px 38px;
            font-size: 20px; /* mais leg√≠vel */
            font-family: 'Montserrat', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 600;
            border: 3px solid white;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.9);
            color: #764ba2;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .difficultyBtn:hover {
            background: white;
            color: #764ba2;
            transform: scale(1.05);
        }

        .difficultyBtn.selected {
            background: #764ba2;
            color: white;
            border-color: #764ba2;
        }

        #startBtn {
            padding: 20px 56px;
            font-size: 28px; /* mais vis√≠vel */
            font-family: 'Montserrat', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: 3px solid white;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            animation: pulseButton 2s infinite;
        }

        @keyframes pulseButton {
            0%, 100% { transform: scale(1); box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4); }
            50% { transform: scale(1.05); box-shadow: 0 15px 40px rgba(0, 0, 0, 0.6); }
        }

        #startBtn:hover {
            transform: scale(1.1);
        }

        /* √Årea do jogo */
        #gameContainer {
            width: 100%;
            height: 100%;
            position: relative;
            display: none;
        }

        #gameContainer.active {
            display: block;
        }

        /* HUD do jogo para desktop - separado da sequ√™ncia */
        #gameHUD {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 25px;
            border-radius: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            z-index: 100;
            /* Sem sequ√™ncia agora */
        }

        #roundInfo {
            font-size: 30px;
            color: #666;
            font-weight: bold;
        }

        #targetDisplay {
            display: flex;
            font-size: 22px;
            font-weight: bold;
            color: #764ba2;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        #counter {
            display: inline-flex;
            margin-left: 10px;
            font-size: 28px;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea, #764ba2);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

  
        /* Sequ√™ncia separada para desktop */
        #sequenceTracker {
            position: absolute;
            top: 140px;
            left: 280px;
            display: grid;

            /* ‚Üë aumenta a altura de cada linha (22px ‚Üí 32px, por ex.) */
            grid-auto-rows: 23px!important;

            /* ‚Üë aumenta espa√ßo entre itens (4px ‚Üí 6 ou 8px) */
            row-gap: 6px!important;

            grid-template-columns: 1fr;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);

            /* ‚Üë padding maior para dar ‚Äúrespiro‚Äù interno */
            padding: 10px 14px!important;

            border-radius: 24px;
            box-shadow: 0 6px 24px rgba(0, 0, 0, 0.08);
            z-index: 99;

            /* ‚Üë largura m√°xima maior */
            max-width: 90px!important;
        }

        .seqItem {
            width: 100%;

            /* ‚Üë m√≠nimo maior para caber o texto ampliado */
            min-width: 65px!important;

            display: flex;
            align-items: center;
            justify-content: center;

            background: rgba(118, 75, 162, 0.08);
            color: #764ba2;
            border: 1px solid rgba(118, 75, 162, 0.25);
            border-radius: 10px;

            /* ‚Üë fonte maior */
            font-size: 14px!important;
            font-weight: 600 !important;
            letter-spacing: .5px;
            transition: all 0.3s ease;
        }

        /* Estados do sequenceTracker */
        .seqItem.done {
            background: rgba(52, 168, 83, 0.9);
            color: white;
            border-color: #34a853;
            box-shadow: 0 2px 8px rgba(52, 168, 83, 0.3);
        }

        .seqItem.current {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-color: #667eea;
            box-shadow: 0 2px 12px rgba(102, 126, 234, 0.4);
            animation: currentPulse 1.5s ease-in-out infinite;
        }

        @keyframes currentPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* seus estilos existentes‚Ä¶ */
        #gameHUD{ position:absolute; top:20px; left:20px; }

        /* valores default (ser√£o sobrescritos no desktop pelo JS) */
        #sequenceTracker{ position:absolute; top:160px; left:280px; }

        /* Desktop apenas: diga que vamos controlar pelo JS */
        @media (min-width:1024px){
        #sequenceTracker{ will-change: top, left; }
        }
        

        /* Controles do jogo */
        #gameControls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .gameControlBtn {
            width: 55px;
            height: 55px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .gameControlBtn:hover {
            transform: scale(1.1);
            background: white;
        }

        /* Varinha de sab√£o */
        #bubbleWand {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 100px;
            z-index: 50;
            pointer-events: none;
            animation: wandFloat 3s ease-in-out infinite;
        }

        @keyframes wandFloat {
            0%, 100% { transform: translateX(-50%) translateY(0) rotate(-5deg); }
            50% { transform: translateX(-50%) translateY(-10px) rotate(5deg); }
        }

        .wandCircle {
            width: 100%;
            height: 100%;
            border: 6px solid #FFD700;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.8), rgba(135, 206, 235, 0.4));
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .wandHandle {
            position: absolute;
            bottom: -35px;
            left: 50%;
            transform: translateX(-50%);
            width: 16px;
            height: 40px;
            background: linear-gradient(180deg, #8B4513, #D2691E);
            border-radius: 0 0 8px 8px;
        }

        /* Bolhas */
        /* Bolhas (com hitbox maior e toque mais responsivo) */
.bubble {
        position: absolute;
        border-radius: 50%;
        cursor: pointer;
        /* ‚Äúanel‚Äù clic√°vel invis√≠vel ao redor da bolha */
        padding: clamp(6px, 1.2vw, 14px);
        background-clip: content-box;         /* cor s√≥ no miolo, padding vira hitbox */
        transition: transform 0.12s ease;
        pointer-events: all;
        touch-action: manipulation;           /* reduz atraso no toque */
        -webkit-tap-highlight-color: transparent;
        will-change: transform;               /* performance */
}

.bubbleLabel{
  position: absolute; inset: 0; display:flex; align-items:center; justify-content:center;
  font-weight: 800; color: #fff; text-shadow: 0 2px 4px rgba(0,0,0,.35), 0 0 8px rgba(0,0,0,.25);
  font-size: 18px; letter-spacing: .4px; user-select: none; pointer-events: none;
}
@media (min-width:1025px){ .bubbleLabel{ font-size: 20px; } }

.bubble.wrong{ animation: bubbleShake .22s linear 1; }
@keyframes bubbleShake { 25%{ transform: translateX(-6px); } 50%{ transform: translateX(6px);} 75%{ transform: translateX(-3px);} 100%{ transform: translateX(0);} }

        .bubble:hover {
        transform: scale(1.06);
        }

        .bubble::before {
        content: '';
        position: absolute;
        top: 15%;
        left: 20%;
        width: 30%;
        height: 30%;
        background: radial-gradient(circle, rgba(255, 255, 255, 0.9), transparent);
        border-radius: 50%;
        pointer-events: none;                 /* n√£o bloqueia o toque */
        }

        /* Efeito de estouro (mais real) */
        .pop { position:absolute; left:0; top:0; pointer-events:none; z-index: 300; }
        .pop-ring {
          position:absolute; left:0; top:0; transform: translate(-50%,-50%) scale(.6);
          width: 22px; height: 22px; border: 3px solid var(--pcA, rgba(120,160,255,.9));
          border-radius: 50%; filter: drop-shadow(0 0 8px var(--pcA, rgba(120,160,255,.6)));
          animation: popRing .55s ease-out forwards;
        }
        @keyframes popRing {
          to { transform: translate(-50%,-50%) scale(3.2); opacity: 0; }
        }

        .popDrop {
          position:absolute; left:0; top:0; transform: translate(-50%,-50%);
          width: 10px; height: 10px; border-radius: 50%;
          background: radial-gradient(circle at 30% 30%, var(--pcA, rgba(120,160,255,.95)), rgba(255,255,255,.35) 45%, rgba(255,255,255,0) 72%);
          filter: blur(.2px) drop-shadow(0 0 6px var(--pcA, rgba(120,160,255,.45)));
          animation: popDrop .7s ease-out forwards;
        }
        @keyframes popDrop {
          60% { transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy))) scale(1.08); opacity: .95; }
          100%{ transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy))) scale(.85); opacity: 0; }
        }


        /* Modal de vit√≥ria */
        #victoryModal {
            position: fixed;           /* cobre toda a viewport */
            inset: 0;                  /* top/left/right/bottom: 0 */
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;             /* acima de confetes e HUD */
            pointer-events: auto;      /* garante clique */
        }

        #victoryModal.show {
            display: flex;
            animation: fadeIn 0.3s ease-out;
        }

        .victoryContent {
            background: white;
            padding: 30px;
            border-radius: 30px;
            text-align: center;
            animation: bounceIn 0.5s ease-out;
            max-width: 450px;
        }

        @keyframes bounceIn {
            0% { transform: scale(0); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        #victoryCharacter {
            width: 120px;
            height: 160px;
            margin: 15px auto;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            animation: victoryDance 1s ease-in-out infinite;
        }

        @keyframes victoryDance {
            0%, 100% { transform: rotate(-5deg) scale(1); }
            25% { transform: rotate(5deg) scale(1.1); }
            50% { transform: rotate(-5deg) scale(1); }
            75% { transform: rotate(5deg) scale(1.1); }
        }

        .victoryContent h2 {
            font-size: 32px;
            color: #764ba2;
            margin-bottom: 15px;
        }

        .victoryButtons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
        }

        .victoryBtn {
            padding: 14px 28px;
            font-size: 18px;
            font-family: 'Montserrat', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 600;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .nextRoundBtn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .menuBtn {
            background: white;
            color: #764ba2;
            border: 2px solid #764ba2;
        }

        .victoryBtn:hover {
            transform: scale(1.05);
        }

        /* Confete */
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            animation: confettiFall 3s linear forwards;
            z-index: 650;
            pointer-events: none; /* n√£o bloqueia cliques na vit√≥ria */
        }

        @keyframes confettiFall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }
        
        /* Responsividade Tablet */
/* Responsividade Tablet */
        @media (min-width: 769px) and (max-width: 1100px) {
            #mainContainer {
                width: 92%;
                height: 88vh;
            }

            #header {
                padding: 12px;
            }

            #activityTitle {
                font-size: 24px;
            }

            #menuTitle {
                font-size: 36px;
            }

            .startMenu-content {
                max-width: 450px;
                margin-top: 25vh;
            }

            #difficultySelector {
                flex-direction: row;
                gap: 10px;
            }

            .difficultyBtn { 
                padding: 14px 28px; 
                font-size: 18px; 
            }

            /* HUD principal para tablet - cantinho esquerdo */
            #gameHUD {
                top: 8px;
                left: 8px;
                transform: none; /* Remove centraliza√ß√£o */
                align-items: flex-start; /* Volta alinhamento √† esquerda */
                padding: 10px 15px;
                gap: 5px;
                border-radius: 15px;
                background: rgba(255, 255, 255, 0.9);
                box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
                width: 300px;
                height: 75px;
            }

            #roundInfo {
                font-size: 20px;
                line-height: 1.2;
                margin-bottom: 3px;
                white-space: nowrap;
            }

            #targetDisplay {
                font-size: 17px;
                gap: 8px;
                margin-bottom: 3px;
                white-space: nowrap;
                overflow: hidden;
            }

            #counter {
                font-size: 22px;
                margin-top: -8px;
            }

            #progressBar {
                width: 160px;
                height: 6px;
                margin-top: 2px;
            }

            /* Sequ√™ncia separada para tablet */
            #sequenceTracker {
                top: 83px !important;
                left: 8px;
                background: rgba(255, 255, 255, 0.85);
                backdrop-filter: blur(10px);
                border-radius: 16px;
                padding: 12px 16px !important;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                max-width: 100px !important;
                grid-template-columns: 1fr;
                grid-auto-rows: 28px !important;
                row-gap: 6px !important;
            }

            .seqItem {
                min-width: 60px !important ;
                font-size: 15px !important;
                font-weight: 700 !important;
                border-radius: 8px;
            }

            .gameControlBtn {
                width: 60px;
                height: 60px;
                font-size: 26px;
            }
        }

        /* Responsividade Mobile */
        @media (max-width: 768px) {
            .bg-video {
                object-position: 90% center;
            }
            
            #mainContainer {
                width: 95%;
                height: 90vh;
                border-radius: 20px;
            }

            #header {
                padding: 10px;
            }

            #activityTitle {
                font-size: 20px;
            }

            #menuTitle {
                font-size: 28px;
                margin-bottom: 30px;
            }

            .startMenu-content {
                max-width: 90%;
                margin-top: 30vh;
            }

            #difficultySelector {
                flex-direction: column;
                gap: 15px;
                width: 100%;
            }

            .difficultyBtn { 
                padding: 14px 28px; 
                font-size: 18px; 
                width: 100%; 
            }

            #startBtn { 
                padding: 18px 44px; 
                font-size: 24px; 
            }

            /* HUD principal para mobile - cantinho esquerdo */
            #gameHUD {
                top: 6px;
                left: 6px;
                transform: none; /* Remove qualquer transform */
                align-items: flex-start;
                padding: 6px 10px;
                gap: 3px;
                background: rgba(255, 255, 255, 0.85);
                border-radius: 12px;
                width: 280px;
                height: 55px;
            }

            #roundInfo {
                font-size: 20px;
                line-height: 1.1;
                margin-bottom: 1px;
                white-space: nowrap;
            }

            #targetDisplay {
                font-size: 14px;
                gap: 6px;
                margin-bottom: 1px;
                white-space: nowrap;
                overflow: hidden;
            }

            #counter {
                font-size: 18px;
                margin-bottom: 1px;
            }

            #progressBar {
                width: 120px;
                height: 4px;
                margin-top: 1px;
            }

            /* Sequ√™ncia separada para mobile */
            #sequenceTracker {
                top: 65px;
                left: 5px;
                max-width: 40px;
                padding: 4px 6px;
                grid-auto-rows: 18px;
                row-gap: 3px;
            }

            .seqItem {
                min-width: 28px;
                font-size: 11px;
            }

            #gameControls {
                top: 10px;
                right: 10px;
                flex-direction: column;
                gap: 8px;
            }

            .gameControlBtn {
                width: 38px;
                height: 38px;
                font-size: 18px;
            }

            #bubbleWand {
                width: 70px;
                height: 70px;
                bottom: 20px;
            }

            .wandCircle {
                border-width: 4px;
            }

            .wandHandle {
                width: 12px;
                height: 30px;
                bottom: -25px;
            }

            .victoryContent {
                padding: 20px;
                width: 85%;
            }

            .victoryContent h2 {
                font-size: 26px;
            }

            .victoryButtons {
                flex-direction: column;
                gap: 10px;
            }

            .victoryBtn { 
                padding: 12px 22px; 
                font-size: 16px; 
                width: 100%; 
            }
        }

        /* Responsividade para telas muito pequenas */
        @media (max-width: 480px) {
            #mainContainer {
                width: 98%;
                height: 95vh;
                border-radius: 15px;
            }

            #activityTitle {
                font-size: 18px;
            }

            #menuTitle {
                font-size: 24px;
            }

            .startMenu-content {
                padding: 15px;
            }

            /* HUD principal para telas pequenas */
            #gameHUD {
                top: 5px;
                left: 5px;
                padding: 5px 8px;
                gap: 2px;
                width: 240px;
                height: 50px;
            }
            /* Sequ√™ncia para telas pequenas */
            #sequenceTracker {
                top: 60px !important;
                left: 5px !important;
                max-width: 38px !important;
                padding: 4px 6px !important;
                grid-auto-rows: 16px !important;
                row-gap: 3px !important;
            }

            #sequenceTracker .seqItem {
                min-width: 24px !important;
                font-size: 10px !important;
                font-weight: 600 !important;
            }

            #roundInfo {
                font-size: 17px;
                line-height: 1.1;
                margin-bottom: 1px;
                white-space: nowrap;
            }

            #targetDisplay {
                font-size: 13px;
                gap: 5px;
                margin-bottom: 1px;
                white-space: nowrap;
                overflow: hidden;
            }

            #counter {
                font-size: 16px;
                margin-bottom: 2px;
                margin-left: 2px;
            }

            #progressBar {
                width: 100px;
                height: 3px;
            }

        }


        

        /* Acessibilidade */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        button:focus {
            outline: 3px solid #FFD700;
            outline-offset: 2px;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0,0,0,0);
            white-space: nowrap;
            border: 0;
        }

        /* A11y: garanta que o overlay n√£o bloqueie cliques quando oculto */
        .accessibility-panel-overlay { pointer-events: none; }
        .accessibility-panel-overlay.active { pointer-events: auto; }

        /* A11y: evite que o √≠cone gigante extrapole do bot√£o flutuante */
        .accessibility-float-btn,
        #accessibilityFloatBtn { overflow: hidden; }

        /* Garante que o wrapper do VLibras n√£o intercepte cliques por padr√£o nesta p√°gina */
        [vw-plugin-wrapper] { pointer-events: none !important; }

        /* Ajuste do footer no mobile: menor, transl√∫cido e FIXO somente ao fim do conte√∫do (n√£o sobrep√µe) */
        @media (max-width: 768px) {
          .game-footer-bolhas {
            z-index: 1200;
            backdrop-filter: none;
            background: rgba(255,255,255,0.08); /* pr√≥ximo ao desktop, mais transl√∫cido */
            color: rgba(255,255,255,0.8);
            font-size: 0.62em;   /* menor que antes */
            padding: 4px 6px;     /* mais compacto */
            position: static !important;   /* deixa no fluxo da p√°gina */
            bottom: auto; left: auto; right: auto;
            margin-top: 8px;               /* pequeno respiro do container */
          }
        }

        /* Layout mobile: sem footer fixo; remove compensa√ß√µes e mant√©m respiro */
        @media (max-width: 768px) {
          /* Permite rolar para que o rodap√© nunca cubra conte√∫do */
          body { 
            overflow-y: auto; 
            display: flex;                /* empilha container + footer */
            flex-direction: column;       /* um embaixo do outro */
            justify-content: flex-start;  /* come√ßa do topo */
            align-items: center;          /* centraliza horizontalmente o container */
            min-height: 100vh;
          }
          @supports (height: 100dvh) {
            body { min-height: 100dvh; }
          }
          /* Respiro no topo e no fim do container */
          #mainContainer { margin: 8px 0 12px 0; }
          /* Bot√£o flutuante volta a usar offset padr√£o + safe-area */
          .accessibility-float-btn, #accessibilityFloatBtn {
            bottom: calc(12px + env(safe-area-inset-bottom, 0px));
          }
          /* Garante que o footer ocupe toda a largura do viewport */
          .game-footer-bolhas { align-self: stretch; }
        }
    </style>
</head>
<body>
    <div id="mainContainer">
        <!-- Header com t√≠tulo -->
        <div id="header">
            <h1 id="activityTitle">ü´ß Conte as Bolhas M√°gicas ü´ß</h1>
        </div>

        <!-- √Årea de conte√∫do -->
        <div id="contentArea">
            <!-- Menu Inicial -->
            <div id="startMenu">
              <!-- V√≠deo de fundo -->
              <video id="heroVideo"
                    class="bg-video"
                    autoplay
                    muted
                    loop
                    playsinline
                    preload="metadata"
                    poster="../src/assets/images/cenario-poster.jpg"
                    aria-hidden="true">
                <source src="../src/assets/videos/conta-bolhas-cenario.webm" type="video/webm">
                <source src="../src/assets/videos/conta-bolhas-cenario.mp4" type="video/mp4">
              </video>

              <!-- Leve v√©u para manter legibilidade -->
              <div class="startMenu-overlay"></div>

              <!-- Conte√∫do do menu -->
              <div class="startMenu-content" role="group" aria-label="Menu inicial">
                <h2 id="menuTitle">Vamos Contar Bolhas!</h2>
                <div id="difficultySelector">
                  <button class="difficultyBtn selected" data-level="1" type="button" onclick="selectDifficulty(1)">üåü F√°cil</button>
                  <button class="difficultyBtn" data-level="2" type="button" onclick="selectDifficulty(2)">‚≠ê M√©dio</button>
                  <button class="difficultyBtn" data-level="3" type="button" onclick="selectDifficulty(3)">üí´ Dif√≠cil</button>
                </div>
                <button id="startBtn" type="button" onclick="startGame()">INICIAR</button>
              </div>
            </div>

            <!-- √Årea do Jogo -->
            <div id="gameContainer">
                <!-- HUD do Jogo -->
                <div id="gameHUD">
                    <div id="roundInfo">
                        <span id="levelName">N√≠vel F√°cil</span> - Rodada <span id="currentRound">1</span> de <span id="totalRounds">5</span>
                    </div>
                    <div id="targetDisplay">
                        <span>üéØ Estoure:</span>
                        <span id="targetNumber">5</span>
                        <span>bolhas</span>
                        <span id="counter"><span id="currentCount">0</span>/<span id="totalCount">5</span></span>
                    </div>


                    <div id="sequenceTracker" aria-label="Sequ√™ncia" role="list"></div>
                </div>

                <!-- Controles do Jogo -->
                <div id="gameControls">
                    <button class="gameControlBtn" id="menuBtnInGame" type="button" title="Menu Principal" onclick="backToMenu()">üè†</button>
                    <button class="gameControlBtn" id="soundBtn" type="button" title="Som" onclick="toggleSound()">üîä</button>
                    <button class="gameControlBtn" id="resetRoundBtn" type="button" title="Reiniciar" onclick="resetRound()">üîÑ</button>
                </div>

                <!-- Varinha de sab√£o -->
                <div id="bubbleWand">
                    <div class="wandCircle"></div>
                    <div class="wandHandle"></div>
                </div>
            </div>
        </div>

        <!-- Modal de Vit√≥ria -->
        <div id="victoryModal" role="dialog">
            <div class="victoryContent">
                <h2 id="victoryTitle">üéâ Parab√©ns! üéâ</h2>
                <div id="victoryCharacter"></div>
                <p id="victoryMessage">Voc√™ conseguiu!</p>
                <div class="victoryButtons">
                    <button class="victoryBtn menuBtn" id="victoryMenuBtn" type="button" onclick="backToMenu()">Menu Principal</button>
                    <button class="victoryBtn nextRoundBtn" id="nextActionBtn" type="button" onclick="nextAction()">Pr√≥xima Rodada</button>
                </div>
            </div>
        </div>

        <!-- √Årea para leitores de tela -->
        <div class="sr-only" aria-live="polite" id="screenReaderAnnouncements"></div>
    </div>
        <!-- Footer pequeno e discreto -->
    <footer class="game-footer-bolhas">
        <p>Ferramenta Educacional - Conta Bolhas | Cria√ß√£o e desenvolvimento por Jo√£o Jr</p>
    </footer>

    <script>
        // Estado do jogo
        const gameState = {
            target: 5,
            current: 0,
            level: 1,
            currentRound: 1,
            roundsPerLevel: 5,
            soundEnabled: true,
            bubbles: [],
            animationId: null,
            lastBubbleTime: 0,
            isPlaying: false,
            completedRounds: 0
        };

        // Configura√ß√µes por n√≠vel e rodada
        // ===== AJUSTE DE TAMANHO E LIMITE DE BOLHAS =====
        const levelConfig = {
        1: { 
            name: 'F√°cil',
            rounds: [
            { min: 3, max: 5,  size: { min: 80, max: 110 }, speed: { min: 0.8, max: 1.2 }, spawnRate: 2500, movement: 'straight',  maxBubbles: 10 },
            { min: 4, max: 6,  size: { min: 78, max: 105 }, speed: { min: 1.0, max: 1.4 }, spawnRate: 2300, movement: 'slight',    maxBubbles: 10 },
            { min: 5, max: 7,  size: { min: 74, max: 100 }, speed: { min: 1.2, max: 1.6 }, spawnRate: 2100, movement: 'slight',    maxBubbles: 10 },
            { min: 6, max: 8,  size: { min: 70, max:  95 }, speed: { min: 1.4, max: 1.8 }, spawnRate: 1900, movement: 'moderate',  maxBubbles: 10 },
            { min: 7, max: 10, size: { min: 66, max:  90 }, speed: { min: 1.6, max: 2.0 }, spawnRate: 1700, movement: 'moderate',  maxBubbles: 10 }
            ]
        },
        2: { 
            name: 'M√©dio',
            rounds: [
            { min: 6,  max:  9, size: { min: 62, max: 84 }, speed: { min: 1.5, max: 2.2 }, spawnRate: 1600, movement: 'moderate', maxBubbles: 9 },
            { min: 7,  max: 11, size: { min: 58, max: 80 }, speed: { min: 1.8, max: 2.6 }, spawnRate: 1400, movement: 'zigzag',   maxBubbles: 9 },
            { min: 8,  max: 13, size: { min: 54, max: 76 }, speed: { min: 2.0, max: 2.9 }, spawnRate: 1200, movement: 'zigzag',   maxBubbles: 9 },
            { min: 10, max: 14, size: { min: 52, max: 74 }, speed: { min: 2.2, max: 3.1 }, spawnRate: 1100, movement: 'curved',   maxBubbles: 8 },
            { min: 12, max: 15, size: { min: 50, max: 72 }, speed: { min: 2.4, max: 3.3 }, spawnRate: 1000, movement: 'curved',   maxBubbles: 8 }
            ]
        },
        3: { 
            name: 'Dif√≠cil',
            rounds: [
            { min: 10, max: 14, size: { min: 50, max: 70 }, speed: { min: 2.5, max: 3.5 }, spawnRate: 900,  movement: 'curved',   maxBubbles: 8 },
            { min: 12, max: 16, size: { min: 48, max: 68 }, speed: { min: 2.8, max: 3.8 }, spawnRate: 850,  movement: 'random',   maxBubbles: 8 },
            { min: 14, max: 18, size: { min: 46, max: 66 }, speed: { min: 3.0, max: 4.0 }, spawnRate: 800,  movement: 'random',   maxBubbles: 8 },
            { min: 16, max: 19, size: { min: 44, max: 64 }, speed: { min: 3.2, max: 4.2 }, spawnRate: 750,  movement: 'chaotic',  maxBubbles: 7 },
            { min: 18, max: 20, size: { min: 42, max: 62 }, speed: { min: 3.4, max: 4.4 }, spawnRate: 700,  movement: 'chaotic',  maxBubbles: 7 }
            ]
        }
        };


        // Cores vibrantes para bolhas
        const bubbleColors = [
            'linear-gradient(135deg, rgba(255, 182, 193, 0.8), rgba(255, 105, 180, 0.6))',
            'linear-gradient(135deg, rgba(135, 206, 235, 0.8), rgba(30, 144, 255, 0.6))',
            'linear-gradient(135deg, rgba(144, 238, 144, 0.8), rgba(34, 139, 34, 0.6))',
            'linear-gradient(135deg, rgba(255, 255, 153, 0.8), rgba(255, 215, 0, 0.6))',
            'linear-gradient(135deg, rgba(221, 160, 221, 0.8), rgba(138, 43, 226, 0.6))',
            'linear-gradient(135deg, rgba(255, 218, 185, 0.8), rgba(255, 140, 0, 0.6))',
            'linear-gradient(135deg, rgba(255, 192, 203, 0.8), rgba(255, 20, 147, 0.6))',
            'linear-gradient(135deg, rgba(176, 224, 230, 0.8), rgba(95, 158, 160, 0.6))'
        ];

        // URLs dos personagens
        const characterImages = {
            idle: '../src/assets/images/Mari_Idle.gif',
            victory: '../src/assets/images/Mari_Acerto.gif'
        };

        // Sistema de √°udio
        class AudioManager {
            constructor() {
                this.context = null;
                this.enabled = true;
                this.popNoiseBuffer = null;
            }

            init() {
                if (!this.context && window.AudioContext) {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                }
                // Pr√©-cria um pequeno buffer de ru√≠do para o som de 'plop'
                if (this.context && !this.popNoiseBuffer) {
                    const dur = 0.08; // 80ms
                    const sr = this.context.sampleRate;
                    const buf = this.context.createBuffer(1, Math.ceil(sr * dur), sr);
                    const data = buf.getChannelData(0);
                    for (let i = 0; i < data.length; i++) {
                        // ru√≠do branco com decaimento exponencial suave
                        const t = i / data.length;
                        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - t, 2.2);
                    }
                    this.popNoiseBuffer = buf;
                }
            }

            playPop() {
                if (!this.enabled || !this.context) return;

                const now = this.context.currentTime;

                // 1) Ru√≠do filtrado (estalo do estouro)
                if (this.popNoiseBuffer) {
                    const src = this.context.createBufferSource();
                    src.buffer = this.popNoiseBuffer;

                    const bp = this.context.createBiquadFilter();
                    bp.type = 'bandpass';
                    bp.frequency.value = 1200 + Math.random()*400;
                    bp.Q.value = 2.0;

                    const g1 = this.context.createGain();
                    g1.gain.setValueAtTime(0.35, now);
                    g1.gain.exponentialRampToValueAtTime(0.001, now + 0.12);

                    src.connect(bp); bp.connect(g1); g1.connect(this.context.destination);
                    src.start(now);
                }

                // 2) Oscilador r√°pido (corpo do "plop")
                const osc = this.context.createOscillator();
                const g2 = this.context.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(220 + Math.random()*80, now);
                osc.frequency.exponentialRampToValueAtTime(900 + Math.random()*200, now + 0.07);
                g2.gain.setValueAtTime(0.18, now);
                g2.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
                osc.connect(g2); g2.connect(this.context.destination);
                osc.start(now); osc.stop(now + 0.13);
            }

            playVictory() {
                if (!this.enabled || !this.context) return;
                
                const notes = [523, 659, 784, 1047];
                notes.forEach((freq, i) => {
                    setTimeout(() => {
                        const oscillator = this.context.createOscillator();
                        const gainNode = this.context.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(this.context.destination);
                        
                        oscillator.frequency.value = freq;
                        gainNode.gain.value = 0.2;
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.2);
                        
                        oscillator.start(this.context.currentTime);
                        oscillator.stop(this.context.currentTime + 0.2);
                    }, i * 100);
                });
            }

            playError() {
                if (!this.enabled || !this.context) return;
                const now = this.context.currentTime;
                const osc = this.context.createOscillator();
                const g = this.context.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(260, now);
                g.gain.setValueAtTime(0.18, now);
                g.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                osc.connect(g); g.connect(this.context.destination);
                osc.start(now); osc.stop(now + 0.16);
            }
        }

        const audio = new AudioManager();

        // Inicializa√ß√£o
        function init() {
            audio.init();
            loadProgress();
            setupEventListeners();
            setupCharacters();
        }

        // Configurar personagens
        function setupCharacters() {
            document.getElementById('victoryCharacter').style.backgroundImage = `url('${characterImages.victory}')`;
        }

        // Tenta pr√©-tocar o v√≠deo em background
        const heroVideo = document.getElementById('heroVideo');
        if (heroVideo) {
          heroVideo.play().catch(()=>{});
        }

        // Configurar event listeners
        function setupEventListeners() {
            // Bot√£o iniciar
            const sb = document.getElementById('startBtn');
            if (sb) sb.addEventListener('click', startGame);

            // Sele√ß√£o de dificuldade no menu
            document.querySelectorAll('.difficultyBtn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const target = e.currentTarget || e.target;
                    document.querySelectorAll('.difficultyBtn').forEach(b => b.classList.remove('selected'));
                    target.classList.add('selected');
                    gameState.level = parseInt(target.dataset.level);
                    gameState.currentRound = 1;
                    saveProgress();
                });
            });

            // Controles do jogo
            document.getElementById('menuBtnInGame').addEventListener('click', backToMenu);
            document.getElementById('soundBtn').addEventListener('click', toggleSound);
            document.getElementById('resetRoundBtn').addEventListener('click', resetRound);

            // Bot√µes de vit√≥ria
            document.getElementById('victoryMenuBtn').addEventListener('click', backToMenu);
            document.getElementById('nextActionBtn').addEventListener('click', nextAction);

            // Delega√ß√£o de eventos (fallback) caso algum bind falhe
            document.addEventListener('click', function(e){
                const nextBtn = e.target.closest?.('#nextActionBtn');
                if (nextBtn) { e.preventDefault(); nextAction(); return; }
                const menuBtn = e.target.closest?.('#victoryMenuBtn');
                if (menuBtn) { e.preventDefault(); backToMenu(); return; }
            }, true);

            // Teclado para acessibilidade
            document.addEventListener('keydown', (e) => {
                if (!gameState.isPlaying) return;
                
                if (e.key >= '0' && e.key <= '9') {
                    const num = parseInt(e.key);
                    for (let i = 0; i < num && i < gameState.bubbles.length; i++) {
                        popBubble(gameState.bubbles[i]);
                    }
                }
            });
        }

        // Fallback direto para sele√ß√£o de dificuldade, usado pelos onclick dos bot√µes
        function selectDifficulty(level) {
            document.querySelectorAll('.difficultyBtn').forEach(b => b.classList.remove('selected'));
            const btn = document.querySelector(`.difficultyBtn[data-level="${level}"]`);
            if (btn) btn.classList.add('selected');
            gameState.level = parseInt(level);
            gameState.currentRound = 1;

            // ‚úÖ CORRE√á√ÉO: Reset completo ao trocar de n√≠vel
            gameState.expected = 1;
            gameState.current = 0;  
            saveProgress();
        }

        // Iniciar jogo
        function startGame() {
            document.getElementById('startMenu').classList.add('hidden');
            document.getElementById('gameContainer').classList.add('active');
            gameState.isPlaying = true;
            gameState.currentRound = 1;
            // ‚úÖ CORRE√á√ÉO: Garantir reset completo ao iniciar
            gameState.expected = 1;
            gameState.current = 0;
            startNewRound();
            gameLoop();
            const heroVideo = document.getElementById('heroVideo');
            if (heroVideo) {
              heroVideo.pause();
              heroVideo.currentTime = 0;
            }
        }

        // Voltar ao menu
        function backToMenu() {
            gameState.isPlaying = false;
            gameState.currentRound = 1;
            
            // Limpar bolhas
            gameState.bubbles.forEach(bubble => bubble.element.remove());
            gameState.bubbles = [];
            
            // Esconder modais e mostrar menu
            document.getElementById('victoryModal').classList.remove('show');
            document.getElementById('gameContainer').classList.remove('active');
            document.getElementById('startMenu').classList.remove('hidden');
            const heroVideo = document.getElementById('heroVideo');
            if (heroVideo) {
              heroVideo.play().catch(()=>{});
            }
            
            // Cancelar anima√ß√£o
            if (gameState.animationId) {
                cancelAnimationFrame(gameState.animationId);
                gameState.animationId = null;
            }
        }

        // Alternar som
        function toggleSound() {
            gameState.soundEnabled = !gameState.soundEnabled;
            document.getElementById('soundBtn').textContent = gameState.soundEnabled ? 'üîä' : 'üîá';
            saveProgress();
        }

        // Resetar rodada
        function resetRound() {
            // ‚úÖ CORRE√á√ÉO: Reset completo da rodada
            gameState.expected = 1;
            gameState.current = 0;
            startNewRound();
        }

        // Pr√≥xima a√ß√£o (rodada ou n√≠vel)
        function nextAction() {
            document.getElementById('victoryModal').classList.remove('show');
            
            // Verificar se completou todas as rodadas do n√≠vel
            if (gameState.currentRound >= gameState.roundsPerLevel) {
                // Passou de n√≠vel
                if (gameState.level < 3) {
                    gameState.level++;
                    gameState.currentRound = 1;
                    
                    // Atualizar sele√ß√£o de dificuldade
                    document.querySelectorAll('.difficultyBtn').forEach(btn => {
                        btn.classList.toggle('selected', parseInt(btn.dataset.level) === gameState.level);
                    });
                    
                    announce(`Parab√©ns! Voc√™ avan√ßou para o n√≠vel ${levelConfig[gameState.level].name}!`);
                } else {
                    // Completou todos os n√≠veis - reinicia do 1
                    gameState.level = 1;
                    gameState.currentRound = 1;
                    // ‚úÖ CORRE√á√ÉO: Reset completo ao completar todos os n√≠veis
                    gameState.expected = 1;
                    gameState.current = 0;
                    announce('Incr√≠vel! Voc√™ completou todos os n√≠veis! Vamos jogar novamente!');
                }
            } else {
                // Pr√≥xima rodada do mesmo n√≠vel
                gameState.currentRound++;
                // ‚úÖ CORRE√á√ÉO: Reset da sequ√™ncia para pr√≥xima rodada
                gameState.expected = 1;
                gameState.current = 0;
            }
            
            saveProgress();
            startNewRound();
        }

        // Nova rodada
        function startNewRound() {
            const config = levelConfig[gameState.level].rounds[gameState.currentRound - 1];
            gameState.target = Math.floor(Math.random() * (config.max - config.min + 1)) + config.min;
            gameState.current = 0;
            
            gameState.expected = 1;

            // Limpar bolhas existentes
            gameState.bubbles.forEach(bubble => bubble.element.remove());
            gameState.bubbles = [];
            
            // Atualizar UI
            updateDisplay();
            //updateProgressBar();
            // Garante primeira bolha 
            gameState.lastBubbleTime = 0;
            createBubble(1);
            
            // Anunciar para leitores de tela
            announce(`Rodada ${gameState.currentRound} de ${gameState.roundsPerLevel}. Estoure ${gameState.target} bolhas. N√≠vel ${levelConfig[gameState.level].name}`);
        }

        // Criar bolha com movimento din√¢mico
        // Fun√ß√£o melhorada para criar bolhas com posi√ß√µes e movimentos mais variados
        function createBubble(forcedNumber) {
            const config = levelConfig[gameState.level].rounds[gameState.currentRound - 1];
            const size = Math.random() * (config.size.max - config.size.min) + config.size.min;
            const speed = Math.random() * (config.speed.max - config.speed.min) + config.speed.min;
            
            const bubble = document.createElement('div');
            bubble.className = 'bubble';
            bubble.style.width = size + 'px';
            bubble.style.height = size + 'px';
            bubble.style.background = bubbleColors[Math.floor(Math.random() * bubbleColors.length)];
            bubble.style.boxShadow = `0 0 20px rgba(255, 255, 255, 0.5), inset 0 0 15px rgba(255, 255, 255, 0.3)`;

            // N√∫mero da bolha conforme dificuldade
            const maxByLevel = {1:20, 2:30, 3:40};
            const maxNum = maxByLevel[gameState.level] || 20;
            const value = forcedNumber || (Math.floor(Math.random() * maxNum) + 1);
            bubble.dataset.value = String(value);
            const label = document.createElement('span');
            label.className = 'bubbleLabel';
            label.textContent = value;
            bubble.appendChild(label);
            
            // ===== NOVO SISTEMA DE POSICIONAMENTO E DIRE√á√ÉO =====
            const containerRect = document.getElementById('contentArea').getBoundingClientRect();
            const containerWidth = containerRect.width;
            const containerHeight = containerRect.height;
            
            // V√°rias op√ß√µes de spawn (entrada das bolhas)
            const spawnOptions = [
                // Da varinha (comportamento original) - 30%
                'wand',
                // Das bordas laterais - 25% cada lado
                'left-edge',
                'right-edge', 
                // Do topo (caindo) - 10%
                'top-edge',
                // De baixo (subindo) - 10%
                'bottom-edge'
            ];
            
            // Probabilidades ajustadas por dificuldade
            let spawnWeights = {1: [0.5, 0.2, 0.2, 0.05, 0.05], 2: [0.3, 0.25, 0.25, 0.1, 0.1], 3: [0.2, 0.2, 0.2, 0.2, 0.2]};
            const weights = spawnWeights[gameState.level];
            const rand = Math.random();
            let cumulative = 0;
            let spawnType = 'wand';
            
            for (let i = 0; i < weights.length; i++) {
                cumulative += weights[i];
                if (rand < cumulative) {
                    spawnType = spawnOptions[i];
                    break;
                }
            }
            
            let startX, startY, vx, vy;
            
            switch(spawnType) {
                case 'wand':
                    // Posicionamento original da varinha com varia√ß√£o
                    const wandRect = document.getElementById('bubbleWand').getBoundingClientRect();
                    const wandVariation = (Math.random() - 0.5) * 100;
                    startX = (wandRect.left - containerRect.left) + wandRect.width / 2 - size / 2 + wandVariation;
                    startY = (wandRect.top - containerRect.top) - size + 50;
                    vx = (Math.random() - 0.5) * speed * 0.5; // movimento horizontal leve
                    vy = -speed; // para cima
                    break;
                    
                case 'left-edge':
                    startX = -size; // fora da tela √† esquerda
                    startY = Math.random() * (containerHeight - size);
                    vx = speed * (0.7 + Math.random() * 0.6); // dire√ß√£o direita
                    vy = (Math.random() - 0.5) * speed * 0.8; // movimento vertical variado
                    break;
                    
                case 'right-edge':
                    startX = containerWidth; // fora da tela √† direita
                    startY = Math.random() * (containerHeight - size);
                    vx = -speed * (0.7 + Math.random() * 0.6); // dire√ß√£o esquerda
                    vy = (Math.random() - 0.5) * speed * 0.8; // movimento vertical variado
                    break;
                    
                case 'top-edge':
                    startX = Math.random() * (containerWidth - size);
                    startY = -size; // fora da tela em cima
                    vx = (Math.random() - 0.5) * speed * 0.6; // movimento horizontal variado
                    vy = speed * (0.5 + Math.random() * 0.8); // para baixo
                    break;
                    
                case 'bottom-edge':
                    startX = Math.random() * (containerWidth - size);
                    startY = containerHeight; // fora da tela embaixo
                    vx = (Math.random() - 0.5) * speed * 0.6; // movimento horizontal variado
                    vy = -speed * (0.5 + Math.random() * 0.8); // para cima
                    break;
            }
            
            bubble.style.left = startX + 'px';
            bubble.style.top = startY + 'px';
            
            // Adicionar ao container do jogo
            document.getElementById('gameContainer').appendChild(bubble);
            
            // ===== MOVIMENTO APRIMORADO =====
            let movementData = {
                type: config.movement,
                amplitude: 0,
                frequency: 0,
                phase: Math.random() * Math.PI * 2,
                direction: Math.random() > 0.5 ? 1 : -1,
                spawnType: spawnType
            };
            
            // Configurar amplitude e frequ√™ncia baseado no movimento
            switch(config.movement) {
                case 'slight':
                    movementData.amplitude = 15 + Math.random() * 10;
                    movementData.frequency = 0.008 + Math.random() * 0.008;
                    break;
                case 'moderate':
                    movementData.amplitude = 25 + Math.random() * 15;
                    movementData.frequency = 0.015 + Math.random() * 0.01;
                    break;
                case 'zigzag':
                    movementData.amplitude = 35 + Math.random() * 25;
                    movementData.frequency = 0.025 + Math.random() * 0.015;
                    break;
                case 'curved':
                    movementData.amplitude = 40 + Math.random() * 30;
                    movementData.frequency = 0.02 + Math.random() * 0.015;
                    break;
                case 'random':
                    movementData.amplitude = 50 + Math.random() * 40;
                    movementData.frequency = 0.03 + Math.random() * 0.02;
                    movementData.changeRate = 0.015;
                    break;
                case 'chaotic':
                    movementData.amplitude = 60 + Math.random() * 50;
                    movementData.frequency = 0.04 + Math.random() * 0.03;
                    movementData.changeRate = 0.02;
                    movementData.chaos = true;
                    break;
            }
            
            // Criar objeto de bolha com velocidades iniciais
            const bubbleObj = {
                element: bubble,
                x: startX,
                y: startY,
                baseX: startX,
                vx: vx, // velocidade horizontal inicial
                vy: vy, // velocidade vertical inicial
                size: size,
                popped: false,
                movement: movementData,
                time: 0,
                bounceCount: 0 // contador de quiques para variedade
            };
            
            // Event listeners para estourar
            bubble.addEventListener('click', () => popBubble(bubbleObj));
            bubble.addEventListener('pointerdown', (e) => {
                e.preventDefault();
                popBubble(bubbleObj);
            });
            
            gameState.bubbles.push(bubbleObj);
            return bubbleObj;
        }


        // Estourar bolha (sequ√™ncia)
        function popBubble(bubbleObj) {
            if (bubbleObj.popped || gameState.current >= gameState.target) return;

            const expected = gameState.expected || 1;
            const val = parseInt(bubbleObj.element.dataset.value || '0', 10);

            // S√≥ estoura se estiver na sequ√™ncia
            if (val !== expected) {
                bubbleObj.element.classList.remove('wrong');
                void bubbleObj.element.offsetWidth; // reflow p/ reiniciar anima√ß√£o
                bubbleObj.element.classList.add('wrong');
                if (gameState.soundEnabled && audio.context && audio.playError) audio.playError();
                return;
            }

            bubbleObj.popped = true;
            gameState.current++;
            gameState.expected = expected + 1;

            // Efeito visual de estouro
            const rect = bubbleObj.element.getBoundingClientRect();
            const containerRect = document.getElementById('contentArea').getBoundingClientRect();
            createPopEffect(
                rect.left - containerRect.left + bubbleObj.size / 2,
                rect.top - containerRect.top + bubbleObj.size / 2,
                bubbleObj.element
            );

            // Som
            if (gameState.soundEnabled && audio.context) {
                audio.playPop();
            }

            // Remover bolha
            bubbleObj.element.remove();
            const index = gameState.bubbles.indexOf(bubbleObj);
            if (index > -1) gameState.bubbles.splice(index, 1);

            // Atualizar UI
            updateDisplay();

            // Verificar vit√≥ria
            if (gameState.current === gameState.target) {
                setTimeout(victory, 300);
            }
        }

        // Efeito de estouro
        function createPopEffect(x, y, sourceEl) {
            const pop = document.createElement('div');
            pop.className = 'pop';
            pop.style.left = x + 'px';
            pop.style.top = y + 'px';

            // Cor da bolha para tingir o efeito
            try {
                if (sourceEl) {
                    const bg = getComputedStyle(sourceEl).backgroundImage || getComputedStyle(sourceEl).backgroundColor;
                    const m = (bg || '').match(/rgba?\([^\)]+\)/); // pega o primeiro rgba()/rgb()
                    if (m) {
                        // se for rgb(a), extrai componentes para garantir alfa
                        const nums = m[0].match(/\d+\.?\d*/g).map(Number);
                        const r = nums[0]||180, g = nums[1]||200, b = nums[2]||255;
                        pop.style.setProperty('--pc', `rgb(${r}, ${g}, ${b})`);
                        pop.style.setProperty('--pcA', `rgba(${r}, ${g}, ${b}, 0.9)`);
                    }
                }
            } catch(_){}

            // Anel de estouro
            const ring = document.createElement('div');
            ring.className = 'pop-ring';
            pop.appendChild(ring);

            // Gotas brilhantes
            const drops = 14;
            for (let i = 0; i < drops; i++) {
                const d = document.createElement('div');
                d.className = 'popDrop';
                const ang = (i / drops) * Math.PI * 2 + (Math.random()*0.6 - 0.3);
                const dist = 32 + Math.random()*28;
                d.style.setProperty('--dx', Math.cos(ang) * dist + 'px');
                d.style.setProperty('--dy', Math.sin(ang) * dist + 'px');
                pop.appendChild(d);
            }

            document.getElementById('gameContainer').appendChild(pop);
            setTimeout(() => pop.remove(), 800);
        }

        // Vit√≥ria
        function victory() {
            if (gameState.soundEnabled && audio.context) {
                audio.playVictory();
            }
            // Confete desativado para n√£o interferir com cliques no modal
            
            // Atualizar mensagem e bot√£o baseado na situa√ß√£o
            const isLastRound = gameState.currentRound >= gameState.roundsPerLevel;
            const isLastLevel = gameState.level >= 3;
            
            let title = 'üéâ Muito Bem! üéâ';
            let message = `Rodada ${gameState.currentRound} completa!`;
            let buttonText = 'Pr√≥xima Rodada';
            
            if (isLastRound) {
                if (isLastLevel) {
                    title = 'üèÜ Incr√≠vel! üèÜ';
                    message = 'Voc√™ completou todos os desafios!';
                    buttonText = 'Jogar Novamente';
                } else {
                    title = '‚≠ê Excelente! ‚≠ê';
                    message = `N√≠vel ${levelConfig[gameState.level].name} completo! Pr√≥ximo: ${levelConfig[gameState.level + 1].name}`;
                    buttonText = 'Pr√≥ximo N√≠vel';
                }
            }
            
            document.getElementById('victoryTitle').textContent = title;
            document.getElementById('victoryMessage').textContent = message;
            document.getElementById('nextActionBtn').textContent = buttonText;
            
            document.getElementById('victoryModal').classList.add('show');
            announce(message);
        }

        // Confete
        function createConfetti() {
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3'];
            for (let i = 0; i < 30; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + '%';
                    confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.animationDelay = Math.random() * 0.5 + 's';
                    document.getElementById('contentArea').appendChild(confetti);
                    setTimeout(() => confetti.remove(), 3000);
                }, i * 50);
            }
        }

        // Game loop com movimento din√¢mico
        // ===== GAME LOOP COM F√çSICA APRIMORADA =====
        function gameLoop() {
            if (!gameState.isPlaying) return;
            
            const now = Date.now();
            const config = levelConfig[gameState.level].rounds[gameState.currentRound - 1];
            
            // L√≥gica de cria√ß√£o de bolhas (mant√©m a mesma do c√≥digo anterior)
            const expectedNum = gameState.expected || 1;
            const hasExpectedBubble = gameState.bubbles.some(b => 
                !b.popped && parseInt(b.element.dataset.value || '0', 10) === expectedNum
            );
            
            if (!hasExpectedBubble && expectedNum <= gameState.target) {
                createBubble(expectedNum);
                gameState.lastBubbleTime = now;
            }
            else if (now - gameState.lastBubbleTime > config.spawnRate && gameState.bubbles.length < config.maxBubbles) {
                if (Math.random() < 0.7 && !hasExpectedBubble && expectedNum <= gameState.target) {
                    createBubble(expectedNum);
                } else {
                    createBubble();
                }
                gameState.lastBubbleTime = now;
            }
            
            // ===== F√çSICA DE MOVIMENTO APRIMORADA =====
            const cont = document.getElementById('contentArea');
            const containerWidth = cont.clientWidth;
            const containerHeight = cont.clientHeight;
            
            gameState.bubbles.forEach(bubble => {
                if (!bubble.popped) {
                    bubble.time++;
                    
                    // ===== MOVIMENTO BASE (velocidade) =====
                    bubble.x += bubble.vx;
                    bubble.y += bubble.vy;
                    
                    // ===== MOVIMENTO ADICIONAL (padr√µes) =====
                    let deltaX = 0, deltaY = 0;
                    
                    switch(bubble.movement.type) {
                        case 'straight':
                            // S√≥ movimento base
                            break;
                            
                        case 'slight':
                        case 'moderate':
                            deltaX = Math.sin(bubble.time * bubble.movement.frequency + bubble.movement.phase) * 
                                    bubble.movement.amplitude * bubble.movement.direction;
                            break;
                            
                        case 'zigzag':
                            deltaX = Math.sin(bubble.time * bubble.movement.frequency) * 
                                    bubble.movement.amplitude * bubble.movement.direction;
                            deltaY = Math.cos(bubble.time * bubble.movement.frequency * 0.7) * 
                                    bubble.movement.amplitude * 0.3;
                            break;
                            
                        case 'curved':
                            const curveTime = bubble.time * 0.01;
                            deltaX = Math.sin(bubble.time * bubble.movement.frequency + bubble.movement.phase) * 
                                    bubble.movement.amplitude * (1 + Math.sin(curveTime)) * bubble.movement.direction;
                            deltaY = Math.cos(bubble.time * bubble.movement.frequency * 0.8) * 
                                    bubble.movement.amplitude * 0.4;
                            break;
                            
                        case 'random':
                            if (Math.random() < bubble.movement.changeRate) {
                                bubble.movement.direction *= -1;
                                // Adicionar pequena varia√ß√£o na velocidade base
                                bubble.vx += (Math.random() - 0.5) * 0.2;
                                bubble.vy += (Math.random() - 0.5) * 0.2;
                            }
                            deltaX = Math.sin(bubble.time * bubble.movement.frequency + bubble.movement.phase) * 
                                    bubble.movement.amplitude * bubble.movement.direction;
                            deltaY = Math.cos(bubble.time * bubble.movement.frequency * 1.3) * 
                                    bubble.movement.amplitude * 0.5;
                            break;
                            
                        case 'chaotic':
                            if (Math.random() < bubble.movement.changeRate) {
                                bubble.movement.direction *= -1;
                                bubble.movement.frequency += (Math.random() - 0.5) * 0.008;
                                // Varia√ß√£o mais forte na velocidade
                                bubble.vx += (Math.random() - 0.5) * 0.4;
                                bubble.vy += (Math.random() - 0.5) * 0.4;
                            }
                            const chaos1 = Math.sin(bubble.time * bubble.movement.frequency + bubble.movement.phase);
                            const chaos2 = Math.cos(bubble.time * bubble.movement.frequency * 1.7 + bubble.movement.phase);
                            deltaX = chaos1 * bubble.movement.amplitude * bubble.movement.direction * (1 + Math.random() * 0.3);
                            deltaY = chaos2 * bubble.movement.amplitude * 0.6 * (1 + Math.random() * 0.4);
                            break;
                    }
                    
                    // Aplicar movimento adicional
                    bubble.x += deltaX * 0.02; // escala menor para n√£o sobrecarregar
                    bubble.y += deltaY * 0.02;
                    
                    // ===== SISTEMA DE QUIQUE APRIMORADO =====
                    const minX = 0;
                    const maxX = containerWidth - bubble.size;
                    const minY = 0;
                    const maxY = containerHeight - bubble.size;
                    
                    // Quique nas bordas com varia√ß√£o
                    if (bubble.x <= minX) {
                        bubble.x = minX;
                        bubble.vx = Math.abs(bubble.vx) * (0.7 + Math.random() * 0.3); // quique com varia√ß√£o
                        bubble.bounceCount++;
                    } else if (bubble.x >= maxX) {
                        bubble.x = maxX;
                        bubble.vx = -Math.abs(bubble.vx) * (0.7 + Math.random() * 0.3);
                        bubble.bounceCount++;
                    }
                    
                    if (bubble.y <= minY) {
                        bubble.y = minY;
                        bubble.vy = Math.abs(bubble.vy) * (0.7 + Math.random() * 0.3);
                        bubble.bounceCount++;
                    } else if (bubble.y >= maxY) {
                        bubble.y = maxY;
                        bubble.vy = -Math.abs(bubble.vy) * (0.7 + Math.random() * 0.3);
                        bubble.bounceCount++;
                    }
                    
                    // Adicionar pequena aleatoriedade ap√≥s v√°rios quiques para evitar loops
                    if (bubble.bounceCount > 0 && bubble.bounceCount % 4 === 0) {
                        bubble.vx += (Math.random() - 0.5) * 0.3;
                        bubble.vy += (Math.random() - 0.5) * 0.3;
                        
                        // Limitar velocidade para n√£o ficar muito r√°pido
                        const maxSpeed = 4;
                        const currentSpeed = Math.sqrt(bubble.vx * bubble.vx + bubble.vy * bubble.vy);
                        if (currentSpeed > maxSpeed) {
                            bubble.vx = (bubble.vx / currentSpeed) * maxSpeed;
                            bubble.vy = (bubble.vy / currentSpeed) * maxSpeed;
                        }
                    }
                    
                    // Aplicar posi√ß√£o final
                    bubble.element.style.left = bubble.x + 'px';
                    bubble.element.style.top = bubble.y + 'px';
                }
            });
            
            gameState.animationId = requestAnimationFrame(gameLoop);
        }

        // Atualizar display
        function updateDisplay() {
            const levelInfo = levelConfig[gameState.level];
            document.getElementById('levelName').textContent = `N√≠vel ${levelInfo.name}`;
            document.getElementById('currentRound').textContent = gameState.currentRound;
            document.getElementById('totalRounds').textContent = gameState.roundsPerLevel;
            document.getElementById('targetNumber').textContent = gameState.target;
            document.getElementById('currentCount').textContent = gameState.current; // mant√©m para acessibilidade
            document.getElementById('totalCount').textContent = gameState.target;

            renderSequenceTracker();
        }

        // Atualizar barra de progresso
        /*function updateProgressBar() {
            const totalProgress = ((gameState.level - 1) * gameState.roundsPerLevel + gameState.currentRound - 1) / (3 * gameState.roundsPerLevel) * 100;
            document.getElementById('progressFill').style.width = totalProgress + '%';
        }*/

        function renderSequenceTracker(){
            const cont = document.getElementById('sequenceTracker');
            if (!cont) return;
            cont.innerHTML = '';
            for (let i=1; i<=gameState.target; i++){
                const el = document.createElement('div');
                el.className = 'seqItem' + (i < gameState.expected ? ' done' : i === gameState.expected ? ' current' : '');
                el.setAttribute('role','listitem');
                el.textContent = i;
                cont.appendChild(el);
            }
        }

        // Anunciar para leitores de tela
        function announce(message) {
            const announcer = document.getElementById('screenReaderAnnouncements');
            announcer.textContent = message;
        }

        // Salvar progresso
        function saveProgress() {
            const saved = {
                level: gameState.level,
                currentRound: gameState.currentRound,
                soundEnabled: gameState.soundEnabled
            };
            try {
                localStorage.setItem('bubbleGameState', JSON.stringify(saved));
            } catch(e) {
                console.log('LocalStorage n√£o dispon√≠vel');
            }
        }

        // Carregar progresso
        function loadProgress() {
            try {
                const saved = localStorage.getItem('bubbleGameState');
                if (saved) {
                    const data = JSON.parse(saved);
                    gameState.level = data.level || 1;
                    gameState.currentRound = data.currentRound || 1;
                    gameState.soundEnabled = data.soundEnabled !== false;
                    
                    // Atualizar UI
                    document.querySelectorAll('.difficultyBtn').forEach(btn => {
                        btn.classList.toggle('selected', parseInt(btn.dataset.level) === gameState.level);
                    });
                    document.getElementById('soundBtn').textContent = gameState.soundEnabled ? 'üîä' : 'üîá';
                }
            } catch (e) {
                console.error('Erro ao carregar progresso:', e);
            }
        }

        // Iniciar quando o DOM estiver pronto
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
</script>
    <script>
        (function fixMobileVH(){
            const setVH = () => {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--app-vh', `${vh * 100}px`);
            };
            setVH();
            window.addEventListener('resize', setVH);
            window.addEventListener('orientationchange', setVH);
        })();
        </script>
        <script>
            (function(){
            const GAP = 16; // espa√ßo entre HUD e sequ√™ncia

            function placeSequence(){
                if (window.innerWidth < 1024) return;          // n√£o mexe em mobile/tablet

                const hud = document.getElementById('gameHUD');
                const seq = document.getElementById('sequenceTracker');
                if (!hud || !seq) return;

                const r = hud.getBoundingClientRect();
                // alinha topo e encosta √† direita do HUD com GAP
                seq.style.top  = (r.top + 130 )+ 'px';
                seq.style.left = (r.left + r.width + GAP) + 'px';
                seq.style.zIndex = 99; // abaixo do HUD se a sombra cruzar
            }

            // roda no load e quando a janela mudar de tamanho
            window.addEventListener('load', placeSequence);
            window.addEventListener('resize', placeSequence);
            })();
            </script>


  <!-- ===========================
      Widget de Acessibilidade (c√≥pia padronizada)
      =========================== -->

  <!-- Bot√£o Flutuante de Acessibilidade -->
  <button
    class="accessibility-float-btn"
    id="accessibilityFloatBtn"
    aria-label="Abrir menu de acessibilidade"
    aria-controls="accessibilityPanel"
    aria-expanded="false"
    onclick="toggleAccessibilityPanel()"
  >
    <span class="accessibility-icon" aria-hidden="true">
      <img src="../src/assets/images/icon-acessibilidade.png" alt="">
    </span>
  </button>

  <!-- Overlay -->
  <div
    class="accessibility-panel-overlay"
    id="accessibilityOverlay"
    onclick="closeAccessibilityPanel()"
    aria-hidden="true"
  ></div>

  <!-- Painel de Acessibilidade (drawer √† direita) -->
  <div
    class="accessibility-panel-modern right-drawer"
    id="accessibilityPanel"
    role="dialog"
    aria-modal="true"
    aria-labelledby="accessibilityPanelTitle"
  >
    <div class="panel-header-modern">
      <h2 id="accessibilityPanelTitle">Menu de Acessibilidade</h2>
      <button
        class="close-btn"
        type="button"
        aria-label="Fechar menu de acessibilidade"
        onclick="closeAccessibilityPanel()"
      >
        √ó
      </button>
    </div>

    <!-- √Årea rol√°vel do painel -->
    <div class="panel-content" id="accessibilityPanelContent" tabindex="-1">
      <!-- Perfis de Acessibilidade -->
      <div class="accessibility-profiles">
        <h3>Selecione seu perfil de acessibilidade</h3>
        <div class="profiles-grid">
          <button class="profile-btn" onclick="applyProfile('motor')" data-profile="motor" type="button">
            <span class="profile-icon" aria-hidden="true">ü¶Ω</span>
            <span class="profile-text">Defici√™ncia Motora</span>
          </button>
          <button class="profile-btn" onclick="applyProfile('visual')" data-profile="visual" type="button">
            <span class="profile-icon" aria-hidden="true">üëÅÔ∏è</span>
            <span class="profile-text">Defici√™ncia Visual</span>
          </button>
          <button class="profile-btn" onclick="applyProfile('cognitive')" data-profile="cognitive" type="button">
            <span class="profile-icon" aria-hidden="true">üß†</span>
            <span class="profile-text">Defici√™ncia Cognitiva</span>
          </button>
          <button class="profile-btn" onclick="applyProfile('hearing')" data-profile="hearing" type="button">
            <span class="profile-icon" aria-hidden="true">ü¶ª</span>
            <span class="profile-text">Defici√™ncia Auditiva</span>
          </button>
        </div>
      </div>

      <!-- Ferramentas Individuais -->
      <div class="tools-grid" role="group" aria-label="Ferramentas de acessibilidade">
        <!-- Linha 1 -->
        <button class="tool-btn" onclick="toggleTextToSpeech()" id="ttsBtn" type="button">
          <span class="tool-icon" aria-hidden="true">üîä</span>
          <span class="tool-text">Clique para Ouvir</span>
        </button>

        <button class="tool-btn" onclick="toggleHighContrast()" id="contrastBtn" type="button">
          <span class="tool-icon" aria-hidden="true">üåì</span>
          <span class="tool-text">Alto Contraste</span>
        </button>

        <button class="tool-btn" onclick="toggleDarkMode()" id="darkModeBtn" type="button">
          <span class="tool-icon" aria-hidden="true">üåô</span>
          <span class="tool-text">Modo Escuro</span>
        </button>

        <!-- Linha 2 -->
        <button class="tool-btn" onclick="decreaseFontSize()" id="decreaseFontBtn" type="button">
          <span class="tool-icon" aria-hidden="true">üî§</span>
          <span class="tool-text">Diminuir Fonte</span>
        </button>

        <button class="tool-btn" onclick="increaseFontSize()" id="increaseFontBtn" type="button">
          <span class="tool-icon" aria-hidden="true">üî†</span>
          <span class="tool-text">Aumentar Fonte</span>
        </button>

        <button class="tool-btn" onclick="toggleDyslexiaFont()" id="dyslexiaBtn" type="button">
          <span class="tool-icon" aria-hidden="true">üìù</span>
          <span class="tool-text">Fonte Dislexia</span>
        </button>

        <!-- Linha 3 -->
        <button class="tool-btn" onclick="toggleGrayscale()" id="grayscaleBtn" type="button">
          <span class="tool-icon" aria-hidden="true">‚ö´</span>
          <span class="tool-text">Monocrom√°tico</span>
        </button>

        <button class="tool-btn" onclick="toggleLowSaturation()" id="lowSatBtn" type="button">
          <span class="tool-icon" aria-hidden="true">üîò</span>
          <span class="tool-text">Baixa Satura√ß√£o</span>
        </button>

        <button class="tool-btn" onclick="toggleHighSaturation()" id="highSatBtn" type="button">
          <span class="tool-icon" aria-hidden="true">üü°</span>
          <span class="tool-text">Alta Satura√ß√£o</span>
        </button>

        <!-- Linha 4 -->
        <button class="tool-btn" onclick="toggleReadingRuler()" id="rulerBtn" type="button">
          <span class="tool-icon" aria-hidden="true">üìè</span>
          <span class="tool-text">R√©gua de Leitura</span>
        </button>

        <button class="tool-btn" onclick="toggleMagnifier()" id="magnifierBtn" type="button">
          <span class="tool-icon" aria-hidden="true">üìñ</span>
          <span class="tool-text">Mascara de Leitura</span>
        </button>

        <button class="tool-btn" onclick="toggleFocusHighlight()" id="focusBtn" type="button">
          <span class="tool-icon" aria-hidden="true">üéØ</span>
          <span class="tool-text">Destacar Links</span>
        </button>

        <!-- Linha 5 -->
        <button class="tool-btn" onclick="pauseAnimations()" id="animationBtn" type="button">
          <span class="tool-icon" aria-hidden="true">‚è∏Ô∏è</span>
          <span class="tool-text">Pausar Anima√ß√µes</span>
        </button>

        <button class="tool-btn" onclick="showKeyboardShortcuts()" type="button">
          <span class="tool-icon" aria-hidden="true">‚å®Ô∏è</span>
          <span class="tool-text">Atalhos Teclado</span>
        </button>

        <!-- (VLibras removido do painel nesta p√°gina) -->

        <!-- Reset de Acessibilidade (ID diferente para n√£o conflitar com reset do jogo) -->
        <button class="tool-btn" onclick="resetAll()" id="a11yResetBtn" type="button">
          <span class="tool-icon" aria-hidden="true">üîÑ</span>
          <span class="tool-text">Resetar Tudo</span>
        </button>
      </div>
    </div>
  </div>

  <!-- Elementos auxiliares fora do painel -->
  <div class="reading-ruler" id="readingRuler" aria-hidden="true"></div>
  <div class="magnifier-circle" id="magnifier" aria-hidden="true"></div>

  <!-- VLibras removido nesta p√°gina -->

  <!-- Desativa VLibras s√≥ nesta p√°gina: evita inje√ß√£o autom√°tica pelo painel -->
  <script>
    try {
      const raw = localStorage.getItem('a11ySettings');
      const s = raw ? JSON.parse(raw) : {};
      s.vlibrasEnabled = false;
      s.timestamp = Date.now();
      localStorage.setItem('a11ySettings', JSON.stringify(s));
      // limpa qualquer flag de carregamento residual
      window.__vlibrasLoaded = false;
    } catch (e) {}
  </script>

  <!-- Script do painel -->
  <script src="../src/js/acessibilidade.js" defer></script>

  <!-- Sem ajustes de VLibras nesta p√°gina -->

</body>
</html>
